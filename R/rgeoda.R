# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -I./libgeoda_src -o rgeoda.cpp rgeoda.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  delayedAssign(defName,  .values, assign.env = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_float_std__allocatorT_float_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_char_std__allocatorT_char_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_int_std__allocatorT_int_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_bool_std__allocatorT_bool_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_long_std__allocatorT_long_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_long_long_std__allocatorT_long_long_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', contains = 'C++Reference')
setClass('_p_GeoDaWeight', contains = 'C++Reference')
setClass('_p_LISA', contains = 'C++Reference')
setClass('_p_AbstractGeoDa', contains = 'C++Reference')
setClass('_p_GeoDaColumn', contains = 'C++Reference')
setClass('_p_GeoDaIntColumn', contains = c('_p_GeoDaColumn'))
setClass('_p_GeoDaStringColumn', contains = c('_p_GeoDaColumn'))
setClass('_p_GeoDaRealColumn', contains = c('_p_GeoDaColumn'))
setClass('_p_GeoDaTable', contains = 'C++Reference')
setClass('_p_GeoDa', contains = c('_p_AbstractGeoDa'))
setClass('_p_PCAResult', contains = 'C++Reference')
setClass('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of VecVoid___nonzero__

`VecVoid___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid___nonzero__`, 'returnType') = 'logical'
attr(`VecVoid___nonzero__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid___nonzero__`) = c("SWIGFunction", class('VecVoid___nonzero__'))

# Start of VecVoid___len__

`VecVoid___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid___len__`, 'returnType') = 'integer'
attr(`VecVoid___len__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid___len__`) = c("SWIGFunction", class('VecVoid___len__'))

# Start of VecVoid_pop

`VecVoid_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid_pop`, 'returnType') = '_p_void'
attr(`VecVoid_pop`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_pop`) = c("SWIGFunction", class('VecVoid_pop'))

# Start of VecVoid___getslice__

`VecVoid___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVoid___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  ans
  
}

attr(`VecVoid___getslice__`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid___getslice__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', 'integer')
class(`VecVoid___getslice__`) = c("SWIGFunction", class('VecVoid___getslice__'))

# Start of VecVoid___setslice__

`VecVoid___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVoid___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVoid___setslice__`, 'returnType') = 'void'
attr(`VecVoid___setslice__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', 'integer', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid___setslice__`) = c("SWIGFunction", class('VecVoid___setslice__'))

# Start of VecVoid___delslice__

`VecVoid___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVoid___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVoid___delslice__`, 'returnType') = 'void'
attr(`VecVoid___delslice__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', 'integer')
class(`VecVoid___delslice__`) = c("SWIGFunction", class('VecVoid___delslice__'))

# Start of VecVoid___delitem__

`VecVoid___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVoid___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVoid___delitem__`, 'returnType') = 'void'
attr(`VecVoid___delitem__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid___delitem__`) = c("SWIGFunction", class('VecVoid___delitem__'))

# Start of VecVoid___getitem__

`VecVoid___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_VecVoid___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid___getitem__`, 'returnType') = '_p_void'
attr(`VecVoid___getitem__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid___getitem__`) = c("SWIGFunction", class('VecVoid___getitem__'))

# Start of VecVoid___setitem__

`VecVoid___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid___setitem__`, 'returnType') = 'void'
attr(`VecVoid___setitem__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', '_p_void')
class(`VecVoid___setitem__`) = c("SWIGFunction", class('VecVoid___setitem__'))

# Start of VecVoid_append

`VecVoid_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_append`, 'returnType') = 'void'
attr(`VecVoid_append`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', '_p_void')
class(`VecVoid_append`) = c("SWIGFunction", class('VecVoid_append'))

# Start of new_VecVoid

`VecVoid__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVoid__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_0`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
class(`VecVoid__SWIG_0`) = c("SWIGFunction", class('VecVoid__SWIG_0'))

# Start of new_VecVoid

`VecVoid__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecVoid__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_1`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid__SWIG_1`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid__SWIG_1`) = c("SWIGFunction", class('VecVoid__SWIG_1'))

# Start of VecVoid_empty

`VecVoid_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid_empty`, 'returnType') = 'logical'
attr(`VecVoid_empty`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_empty`) = c("SWIGFunction", class('VecVoid_empty'))

# Start of VecVoid_size

`VecVoid_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid_size`, 'returnType') = 'integer'
attr(`VecVoid_size`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_size`) = c("SWIGFunction", class('VecVoid_size'))

# Start of VecVoid_swap

`VecVoid_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVoid_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVoid_swap`, 'returnType') = 'void'
attr(`VecVoid_swap`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_swap`) = c("SWIGFunction", class('VecVoid_swap'))

# Start of VecVoid_clear

`VecVoid_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVoid_clear`, 'returnType') = 'void'
attr(`VecVoid_clear`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_clear`) = c("SWIGFunction", class('VecVoid_clear'))

# Start of VecVoid_get_allocator

`VecVoid_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_void_p_t", ref=ans);
  
  ans
  
}

attr(`VecVoid_get_allocator`, 'returnType') = '_p_std__allocatorT_void_p_t'
attr(`VecVoid_get_allocator`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_get_allocator`) = c("SWIGFunction", class('VecVoid_get_allocator'))

# Start of new_VecVoid

`VecVoid__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVoid__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_2`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid__SWIG_2`, "inputTypes") = c('integer')
class(`VecVoid__SWIG_2`) = c("SWIGFunction", class('VecVoid__SWIG_2'))

# Start of VecVoid_pop_back

`VecVoid_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVoid_pop_back`, 'returnType') = 'void'
attr(`VecVoid_pop_back`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_pop_back`) = c("SWIGFunction", class('VecVoid_pop_back'))

# Start of VecVoid_resize

`VecVoid_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVoid_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVoid_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVoid_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid_resize__SWIG_0`) = c("SWIGFunction", class('VecVoid_resize__SWIG_0'))

# Start of new_VecVoid

`VecVoid__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_VecVoid__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_3`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid__SWIG_3`, "inputTypes") = c('integer', '_p_void')
class(`VecVoid__SWIG_3`) = c("SWIGFunction", class('VecVoid__SWIG_3'))

`VecVoid` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVoid__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVoid__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t') && length(argv[[1]]) == 1) {
      f <- VecVoid__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_void') && length(argv[[2]]) == 1) {
      f <- VecVoid__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVoid with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVoid_push_back

`VecVoid_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_push_back`, 'returnType') = 'void'
attr(`VecVoid_push_back`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', '_p_void')
class(`VecVoid_push_back`) = c("SWIGFunction", class('VecVoid_push_back'))

# Start of VecVoid_front

`VecVoid_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_front', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid_front`, 'returnType') = '_p_void'
attr(`VecVoid_front`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_front`) = c("SWIGFunction", class('VecVoid_front'))

# Start of VecVoid_back

`VecVoid_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_back', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid_back`, 'returnType') = '_p_void'
attr(`VecVoid_back`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_back`) = c("SWIGFunction", class('VecVoid_back'))

# Start of VecVoid_assign

`VecVoid_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_assign`, 'returnType') = 'void'
attr(`VecVoid_assign`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', '_p_void')
class(`VecVoid_assign`) = c("SWIGFunction", class('VecVoid_assign'))

# Start of VecVoid_resize

`VecVoid_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVoid_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', '_p_void')
class(`VecVoid_resize__SWIG_1`) = c("SWIGFunction", class('VecVoid_resize__SWIG_1'))

`VecVoid_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVoid_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_void') && length(argv[[3]]) == 1) {
      f <- VecVoid_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVoid_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVoid_reserve

`VecVoid_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVoid_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVoid_reserve`, 'returnType') = 'void'
attr(`VecVoid_reserve`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid_reserve`) = c("SWIGFunction", class('VecVoid_reserve'))

# Start of VecVoid_capacity

`VecVoid_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid_capacity`, 'returnType') = 'integer'
attr(`VecVoid_capacity`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_capacity`) = c("SWIGFunction", class('VecVoid_capacity'))

# Start of delete_VecVoid

`delete_VecVoid` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVoid', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVoid`, 'returnType') = 'void'
attr(`delete_VecVoid`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`delete_VecVoid`) = c("SWIGFunction", class('delete_VecVoid'))

# Start of accessor method for std::vector<(p.void)>
setMethod('$', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVoid___nonzero__, '__len__' = VecVoid___len__, 'pop' = VecVoid_pop, '__getslice__' = VecVoid___getslice__, '__setslice__' = VecVoid___setslice__, '__delslice__' = VecVoid___delslice__, '__delitem__' = VecVoid___delitem__, '__getitem__' = VecVoid___getitem__, '__setitem__' = VecVoid___setitem__, 'append' = VecVoid_append, 'empty' = VecVoid_empty, 'size' = VecVoid_size, 'swap' = VecVoid_swap, 'clear' = VecVoid_clear, 'get_allocator' = VecVoid_get_allocator, 'pop_back' = VecVoid_pop_back, 'resize' = VecVoid_resize, 'push_back' = VecVoid_push_back, 'front' = VecVoid_front, 'back' = VecVoid_back, 'assign' = VecVoid_assign, 'reserve' = VecVoid_reserve, 'capacity' = VecVoid_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(p.void)>
setMethod('delete', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', function(obj) {delete_std__vectorT_void_p_std__allocatorT_void_p_t_t(obj)})
# Start of VecFloat___nonzero__

`VecFloat___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat___nonzero__`, 'returnType') = 'logical'
attr(`VecFloat___nonzero__`, "inputTypes") = c('numeric')
class(`VecFloat___nonzero__`) = c("SWIGFunction", class('VecFloat___nonzero__'))

# Start of VecFloat___len__

`VecFloat___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat___len__`, 'returnType') = 'integer'
attr(`VecFloat___len__`, "inputTypes") = c('numeric')
class(`VecFloat___len__`) = c("SWIGFunction", class('VecFloat___len__'))

# Start of VecFloat_pop

`VecFloat_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_pop`, 'returnType') = 'numeric'
attr(`VecFloat_pop`, "inputTypes") = c('numeric')
class(`VecFloat_pop`) = c("SWIGFunction", class('VecFloat_pop'))

# Start of VecFloat___getslice__

`VecFloat___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecFloat___getslice__`, 'returnType') = 'numeric'
attr(`VecFloat___getslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___getslice__`) = c("SWIGFunction", class('VecFloat___getslice__'))

# Start of VecFloat___setslice__

`VecFloat___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecFloat___setslice__`, 'returnType') = 'void'
attr(`VecFloat___setslice__`, "inputTypes") = c('numeric', 'integer', 'integer', 'numeric')
class(`VecFloat___setslice__`) = c("SWIGFunction", class('VecFloat___setslice__'))

# Start of VecFloat___delslice__

`VecFloat___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecFloat___delslice__`, 'returnType') = 'void'
attr(`VecFloat___delslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___delslice__`) = c("SWIGFunction", class('VecFloat___delslice__'))

# Start of VecFloat___delitem__

`VecFloat___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecFloat___delitem__`, 'returnType') = 'void'
attr(`VecFloat___delitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___delitem__`) = c("SWIGFunction", class('VecFloat___delitem__'))

# Start of VecFloat___getitem__

`VecFloat___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat___getitem__`, 'returnType') = 'numeric'
attr(`VecFloat___getitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___getitem__`) = c("SWIGFunction", class('VecFloat___getitem__'))

# Start of VecFloat___setitem__

`VecFloat___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecFloat___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat___setitem__`, 'returnType') = 'void'
attr(`VecFloat___setitem__`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat___setitem__`) = c("SWIGFunction", class('VecFloat___setitem__'))

# Start of VecFloat_append

`VecFloat_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_append`, 'returnType') = 'void'
attr(`VecFloat_append`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_append`) = c("SWIGFunction", class('VecFloat_append'))

# Start of new_VecFloat

`VecFloat__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecFloat__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_0`, 'returnType') = 'numeric'
class(`VecFloat__SWIG_0`) = c("SWIGFunction", class('VecFloat__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_VecFloat__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_1`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_1`, "inputTypes") = c('numeric')
class(`VecFloat__SWIG_1`) = c("SWIGFunction", class('VecFloat__SWIG_1'))

# Start of VecFloat_empty

`VecFloat_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_empty`, 'returnType') = 'logical'
attr(`VecFloat_empty`, "inputTypes") = c('numeric')
class(`VecFloat_empty`) = c("SWIGFunction", class('VecFloat_empty'))

# Start of VecFloat_size

`VecFloat_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_size`, 'returnType') = 'integer'
attr(`VecFloat_size`, "inputTypes") = c('numeric')
class(`VecFloat_size`) = c("SWIGFunction", class('VecFloat_size'))

# Start of VecFloat_swap

`VecFloat_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecFloat_swap`, 'returnType') = 'void'
attr(`VecFloat_swap`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_swap`) = c("SWIGFunction", class('VecFloat_swap'))

# Start of VecFloat_clear

`VecFloat_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecFloat_clear`, 'returnType') = 'void'
attr(`VecFloat_clear`, "inputTypes") = c('numeric')
class(`VecFloat_clear`) = c("SWIGFunction", class('VecFloat_clear'))

# Start of VecFloat_get_allocator

`VecFloat_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecFloat_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_float_t", ref=ans);
  
  ans
  
}

attr(`VecFloat_get_allocator`, 'returnType') = '_p_std__allocatorT_float_t'
attr(`VecFloat_get_allocator`, "inputTypes") = c('numeric')
class(`VecFloat_get_allocator`) = c("SWIGFunction", class('VecFloat_get_allocator'))

# Start of new_VecFloat

`VecFloat__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecFloat__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_2`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_2`, "inputTypes") = c('integer')
class(`VecFloat__SWIG_2`) = c("SWIGFunction", class('VecFloat__SWIG_2'))

# Start of VecFloat_pop_back

`VecFloat_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecFloat_pop_back`, 'returnType') = 'void'
attr(`VecFloat_pop_back`, "inputTypes") = c('numeric')
class(`VecFloat_pop_back`) = c("SWIGFunction", class('VecFloat_pop_back'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecFloat_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecFloat_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_0`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_resize__SWIG_0`) = c("SWIGFunction", class('VecFloat_resize__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecFloat__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_3`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecFloat__SWIG_3`) = c("SWIGFunction", class('VecFloat__SWIG_3'))

`VecFloat` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecFloat__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecFloat__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecFloat__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecFloat__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_push_back

`VecFloat_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_push_back`, 'returnType') = 'void'
attr(`VecFloat_push_back`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_push_back`) = c("SWIGFunction", class('VecFloat_push_back'))

# Start of VecFloat_front

`VecFloat_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_front`, 'returnType') = 'numeric'
attr(`VecFloat_front`, "inputTypes") = c('numeric')
class(`VecFloat_front`) = c("SWIGFunction", class('VecFloat_front'))

# Start of VecFloat_back

`VecFloat_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_back`, 'returnType') = 'numeric'
attr(`VecFloat_back`, "inputTypes") = c('numeric')
class(`VecFloat_back`) = c("SWIGFunction", class('VecFloat_back'))

# Start of VecFloat_assign

`VecFloat_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecFloat_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_assign`, 'returnType') = 'void'
attr(`VecFloat_assign`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_assign`) = c("SWIGFunction", class('VecFloat_assign'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecFloat_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_1`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_resize__SWIG_1`) = c("SWIGFunction", class('VecFloat_resize__SWIG_1'))

`VecFloat_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecFloat_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecFloat_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_reserve

`VecFloat_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecFloat_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecFloat_reserve`, 'returnType') = 'void'
attr(`VecFloat_reserve`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_reserve`) = c("SWIGFunction", class('VecFloat_reserve'))

# Start of VecFloat_capacity

`VecFloat_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_capacity`, 'returnType') = 'integer'
attr(`VecFloat_capacity`, "inputTypes") = c('numeric')
class(`VecFloat_capacity`) = c("SWIGFunction", class('VecFloat_capacity'))

# Start of delete_VecFloat

`delete_VecFloat` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecFloat', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecFloat`, 'returnType') = 'void'
attr(`delete_VecFloat`, "inputTypes") = c('numeric')
class(`delete_VecFloat`) = c("SWIGFunction", class('delete_VecFloat'))

# Start of accessor method for std::vector<(float)>
setMethod('$', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecFloat___nonzero__, '__len__' = VecFloat___len__, 'pop' = VecFloat_pop, '__getslice__' = VecFloat___getslice__, '__setslice__' = VecFloat___setslice__, '__delslice__' = VecFloat___delslice__, '__delitem__' = VecFloat___delitem__, '__getitem__' = VecFloat___getitem__, '__setitem__' = VecFloat___setitem__, 'append' = VecFloat_append, 'empty' = VecFloat_empty, 'size' = VecFloat_size, 'swap' = VecFloat_swap, 'clear' = VecFloat_clear, 'get_allocator' = VecFloat_get_allocator, 'pop_back' = VecFloat_pop_back, 'resize' = VecFloat_resize, 'push_back' = VecFloat_push_back, 'front' = VecFloat_front, 'back' = VecFloat_back, 'assign' = VecFloat_assign, 'reserve' = VecFloat_reserve, 'capacity' = VecFloat_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(float)>
setMethod('delete', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(obj) {delete_std__vectorT_float_std__allocatorT_float_t_t(obj)})
# Start of VecString___nonzero__

`VecString___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString___nonzero__`, 'returnType') = 'logical'
attr(`VecString___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___nonzero__`) = c("SWIGFunction", class('VecString___nonzero__'))

# Start of VecString___len__

`VecString___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString___len__`, 'returnType') = 'integer'
attr(`VecString___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___len__`) = c("SWIGFunction", class('VecString___len__'))

# Start of VecString_pop

`VecString_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_pop`, 'returnType') = 'character'
attr(`VecString_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop`) = c("SWIGFunction", class('VecString_pop'))

# Start of VecString___getslice__

`VecString___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecString___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`VecString___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___getslice__`) = c("SWIGFunction", class('VecString___getslice__'))

# Start of VecString___setslice__

`VecString___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecString___setslice__`, 'returnType') = 'void'
attr(`VecString___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___setslice__`) = c("SWIGFunction", class('VecString___setslice__'))

# Start of VecString___delslice__

`VecString___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecString___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecString___delslice__`, 'returnType') = 'void'
attr(`VecString___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___delslice__`) = c("SWIGFunction", class('VecString___delslice__'))

# Start of VecString___delitem__

`VecString___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecString___delitem__`, 'returnType') = 'void'
attr(`VecString___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___delitem__`) = c("SWIGFunction", class('VecString___delitem__'))

# Start of VecString___getitem__

`VecString___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString___getitem__`, 'returnType') = 'character'
attr(`VecString___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___getitem__`) = c("SWIGFunction", class('VecString___getitem__'))

# Start of VecString___setitem__

`VecString___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecString___setitem__`, 'returnType') = 'void'
attr(`VecString___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString___setitem__`) = c("SWIGFunction", class('VecString___setitem__'))

# Start of VecString_append

`VecString_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecString_append`, 'returnType') = 'void'
attr(`VecString_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_append`) = c("SWIGFunction", class('VecString_append'))

# Start of new_VecString

`VecString__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecString__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`VecString__SWIG_0`) = c("SWIGFunction", class('VecString__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecString__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString__SWIG_1`) = c("SWIGFunction", class('VecString__SWIG_1'))

# Start of VecString_empty

`VecString_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_empty`, 'returnType') = 'logical'
attr(`VecString_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_empty`) = c("SWIGFunction", class('VecString_empty'))

# Start of VecString_size

`VecString_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_size`, 'returnType') = 'integer'
attr(`VecString_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_size`) = c("SWIGFunction", class('VecString_size'))

# Start of VecString_swap

`VecString_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecString_swap`, 'returnType') = 'void'
attr(`VecString_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_swap`) = c("SWIGFunction", class('VecString_swap'))

# Start of VecString_clear

`VecString_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecString_clear`, 'returnType') = 'void'
attr(`VecString_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_clear`) = c("SWIGFunction", class('VecString_clear'))

# Start of VecString_get_allocator

`VecString_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecString_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`VecString_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`VecString_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_get_allocator`) = c("SWIGFunction", class('VecString_get_allocator'))

# Start of new_VecString

`VecString__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecString__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_2`, "inputTypes") = c('integer')
class(`VecString__SWIG_2`) = c("SWIGFunction", class('VecString__SWIG_2'))

# Start of VecString_pop_back

`VecString_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecString_pop_back`, 'returnType') = 'void'
attr(`VecString_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop_back`) = c("SWIGFunction", class('VecString_pop_back'))

# Start of VecString_resize

`VecString_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecString_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecString_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_resize__SWIG_0`) = c("SWIGFunction", class('VecString_resize__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_VecString__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`VecString__SWIG_3`) = c("SWIGFunction", class('VecString__SWIG_3'))

`VecString` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecString__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecString__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- VecString__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecString__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecString with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_push_back

`VecString_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecString_push_back`, 'returnType') = 'void'
attr(`VecString_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_push_back`) = c("SWIGFunction", class('VecString_push_back'))

# Start of VecString_front

`VecString_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_front`, 'returnType') = 'character'
attr(`VecString_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_front`) = c("SWIGFunction", class('VecString_front'))

# Start of VecString_back

`VecString_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_back`, 'returnType') = 'character'
attr(`VecString_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_back`) = c("SWIGFunction", class('VecString_back'))

# Start of VecString_assign

`VecString_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecString_assign`, 'returnType') = 'void'
attr(`VecString_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_assign`) = c("SWIGFunction", class('VecString_assign'))

# Start of VecString_resize

`VecString_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecString_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_resize__SWIG_1`) = c("SWIGFunction", class('VecString_resize__SWIG_1'))

`VecString_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecString_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecString_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecString_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_reserve

`VecString_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecString_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecString_reserve`, 'returnType') = 'void'
attr(`VecString_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_reserve`) = c("SWIGFunction", class('VecString_reserve'))

# Start of VecString_capacity

`VecString_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_capacity`, 'returnType') = 'integer'
attr(`VecString_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_capacity`) = c("SWIGFunction", class('VecString_capacity'))

# Start of delete_VecString

`delete_VecString` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecString', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecString`, 'returnType') = 'void'
attr(`delete_VecString`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_VecString`) = c("SWIGFunction", class('delete_VecString'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecString___nonzero__, '__len__' = VecString___len__, 'pop' = VecString_pop, '__getslice__' = VecString___getslice__, '__setslice__' = VecString___setslice__, '__delslice__' = VecString___delslice__, '__delitem__' = VecString___delitem__, '__getitem__' = VecString___getitem__, '__setitem__' = VecString___setitem__, 'append' = VecString_append, 'empty' = VecString_empty, 'size' = VecString_size, 'swap' = VecString_swap, 'clear' = VecString_clear, 'get_allocator' = VecString_get_allocator, 'pop_back' = VecString_pop_back, 'resize' = VecString_resize, 'push_back' = VecString_push_back, 'front' = VecString_front, 'back' = VecString_back, 'assign' = VecString_assign, 'reserve' = VecString_reserve, 'capacity' = VecString_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of VecDouble___nonzero__

`VecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecDouble___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___nonzero__`) = c("SWIGFunction", class('VecDouble___nonzero__'))

# Start of VecDouble___len__

`VecDouble___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble___len__`, 'returnType') = 'integer'
attr(`VecDouble___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___len__`) = c("SWIGFunction", class('VecDouble___len__'))

# Start of VecDouble_pop

`VecDouble_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_pop`, 'returnType') = 'numeric'
attr(`VecDouble_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop`) = c("SWIGFunction", class('VecDouble_pop'))

# Start of VecDouble___getslice__

`VecDouble___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecDouble___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___getslice__`) = c("SWIGFunction", class('VecDouble___getslice__'))

# Start of VecDouble___setslice__

`VecDouble___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecDouble___setslice__`, 'returnType') = 'void'
attr(`VecDouble___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___setslice__`) = c("SWIGFunction", class('VecDouble___setslice__'))

# Start of VecDouble___delslice__

`VecDouble___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecDouble___delslice__`, 'returnType') = 'void'
attr(`VecDouble___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___delslice__`) = c("SWIGFunction", class('VecDouble___delslice__'))

# Start of VecDouble___delitem__

`VecDouble___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecDouble___delitem__`, 'returnType') = 'void'
attr(`VecDouble___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___delitem__`) = c("SWIGFunction", class('VecDouble___delitem__'))

# Start of VecDouble___getitem__

`VecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble___getitem__`, 'returnType') = 'numeric'
attr(`VecDouble___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___getitem__`) = c("SWIGFunction", class('VecDouble___getitem__'))

# Start of VecDouble___setitem__

`VecDouble___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecDouble___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble___setitem__`, 'returnType') = 'void'
attr(`VecDouble___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble___setitem__`) = c("SWIGFunction", class('VecDouble___setitem__'))

# Start of VecDouble_append

`VecDouble_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_append`, 'returnType') = 'void'
attr(`VecDouble_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_append`) = c("SWIGFunction", class('VecDouble_append'))

# Start of new_VecDouble

`VecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecDouble__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`VecDouble__SWIG_0`) = c("SWIGFunction", class('VecDouble__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_VecDouble__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble__SWIG_1`) = c("SWIGFunction", class('VecDouble__SWIG_1'))

# Start of VecDouble_empty

`VecDouble_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_empty`, 'returnType') = 'logical'
attr(`VecDouble_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_empty`) = c("SWIGFunction", class('VecDouble_empty'))

# Start of VecDouble_size

`VecDouble_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_size`, 'returnType') = 'integer'
attr(`VecDouble_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_size`) = c("SWIGFunction", class('VecDouble_size'))

# Start of VecDouble_swap

`VecDouble_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecDouble_swap`, 'returnType') = 'void'
attr(`VecDouble_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_swap`) = c("SWIGFunction", class('VecDouble_swap'))

# Start of VecDouble_clear

`VecDouble_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecDouble_clear`, 'returnType') = 'void'
attr(`VecDouble_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_clear`) = c("SWIGFunction", class('VecDouble_clear'))

# Start of VecDouble_get_allocator

`VecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecDouble_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`VecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`VecDouble_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_get_allocator`) = c("SWIGFunction", class('VecDouble_get_allocator'))

# Start of new_VecDouble

`VecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecDouble__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecDouble__SWIG_2`) = c("SWIGFunction", class('VecDouble__SWIG_2'))

# Start of VecDouble_pop_back

`VecDouble_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecDouble_pop_back`, 'returnType') = 'void'
attr(`VecDouble_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop_back`) = c("SWIGFunction", class('VecDouble_pop_back'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecDouble_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecDouble_resize__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecDouble__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecDouble__SWIG_3`) = c("SWIGFunction", class('VecDouble__SWIG_3'))

`VecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecDouble__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_push_back

`VecDouble_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_push_back`, 'returnType') = 'void'
attr(`VecDouble_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_push_back`) = c("SWIGFunction", class('VecDouble_push_back'))

# Start of VecDouble_front

`VecDouble_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_front`, 'returnType') = 'numeric'
attr(`VecDouble_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_front`) = c("SWIGFunction", class('VecDouble_front'))

# Start of VecDouble_back

`VecDouble_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_back`, 'returnType') = 'numeric'
attr(`VecDouble_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_back`) = c("SWIGFunction", class('VecDouble_back'))

# Start of VecDouble_assign

`VecDouble_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecDouble_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_assign`, 'returnType') = 'void'
attr(`VecDouble_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_assign`) = c("SWIGFunction", class('VecDouble_assign'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecDouble_resize__SWIG_1'))

`VecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_reserve

`VecDouble_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecDouble_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecDouble_reserve`, 'returnType') = 'void'
attr(`VecDouble_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_reserve`) = c("SWIGFunction", class('VecDouble_reserve'))

# Start of VecDouble_capacity

`VecDouble_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_capacity`, 'returnType') = 'integer'
attr(`VecDouble_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_capacity`) = c("SWIGFunction", class('VecDouble_capacity'))

# Start of delete_VecDouble

`delete_VecDouble` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecDouble', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecDouble`, 'returnType') = 'void'
attr(`delete_VecDouble`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_VecDouble`) = c("SWIGFunction", class('delete_VecDouble'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecDouble___nonzero__, '__len__' = VecDouble___len__, 'pop' = VecDouble_pop, '__getslice__' = VecDouble___getslice__, '__setslice__' = VecDouble___setslice__, '__delslice__' = VecDouble___delslice__, '__delitem__' = VecDouble___delitem__, '__getitem__' = VecDouble___getitem__, '__setitem__' = VecDouble___setitem__, 'append' = VecDouble_append, 'empty' = VecDouble_empty, 'size' = VecDouble_size, 'swap' = VecDouble_swap, 'clear' = VecDouble_clear, 'get_allocator' = VecDouble_get_allocator, 'pop_back' = VecDouble_pop_back, 'resize' = VecDouble_resize, 'push_back' = VecDouble_push_back, 'front' = VecDouble_front, 'back' = VecDouble_back, 'assign' = VecDouble_assign, 'reserve' = VecDouble_reserve, 'capacity' = VecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of VecChar___nonzero__

`VecChar___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar___nonzero__`, 'returnType') = 'logical'
attr(`VecChar___nonzero__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar___nonzero__`) = c("SWIGFunction", class('VecChar___nonzero__'))

# Start of VecChar___len__

`VecChar___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar___len__`, 'returnType') = 'integer'
attr(`VecChar___len__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar___len__`) = c("SWIGFunction", class('VecChar___len__'))

# Start of VecChar_pop

`VecChar_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_pop`, 'returnType') = 'character'
attr(`VecChar_pop`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_pop`) = c("SWIGFunction", class('VecChar_pop'))

# Start of VecChar___getslice__

`VecChar___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecChar___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecChar___getslice__`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar___getslice__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', 'integer')
class(`VecChar___getslice__`) = c("SWIGFunction", class('VecChar___getslice__'))

# Start of VecChar___setslice__

`VecChar___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecChar___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecChar___setslice__`, 'returnType') = 'void'
attr(`VecChar___setslice__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar___setslice__`) = c("SWIGFunction", class('VecChar___setslice__'))

# Start of VecChar___delslice__

`VecChar___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecChar___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecChar___delslice__`, 'returnType') = 'void'
attr(`VecChar___delslice__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', 'integer')
class(`VecChar___delslice__`) = c("SWIGFunction", class('VecChar___delslice__'))

# Start of VecChar___delitem__

`VecChar___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecChar___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecChar___delitem__`, 'returnType') = 'void'
attr(`VecChar___delitem__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar___delitem__`) = c("SWIGFunction", class('VecChar___delitem__'))

# Start of VecChar___getitem__

`VecChar___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecChar___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar___getitem__`, 'returnType') = '_p_char'
attr(`VecChar___getitem__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar___getitem__`) = c("SWIGFunction", class('VecChar___getitem__'))

# Start of VecChar___setitem__

`VecChar___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character");     
  ;.Call('R_swig_VecChar___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecChar___setitem__`, 'returnType') = 'void'
attr(`VecChar___setitem__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', '_p_char')
class(`VecChar___setitem__`) = c("SWIGFunction", class('VecChar___setitem__'))

# Start of VecChar_append

`VecChar_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_append`, 'returnType') = 'void'
attr(`VecChar_append`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', '_p_char')
class(`VecChar_append`) = c("SWIGFunction", class('VecChar_append'))

# Start of new_VecChar

`VecChar__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecChar__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_0`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
class(`VecChar__SWIG_0`) = c("SWIGFunction", class('VecChar__SWIG_0'))

# Start of new_VecChar

`VecChar__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecChar__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_1`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar__SWIG_1`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar__SWIG_1`) = c("SWIGFunction", class('VecChar__SWIG_1'))

# Start of VecChar_empty

`VecChar_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_empty`, 'returnType') = 'logical'
attr(`VecChar_empty`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_empty`) = c("SWIGFunction", class('VecChar_empty'))

# Start of VecChar_size

`VecChar_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_size`, 'returnType') = 'integer'
attr(`VecChar_size`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_size`) = c("SWIGFunction", class('VecChar_size'))

# Start of VecChar_swap

`VecChar_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecChar_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecChar_swap`, 'returnType') = 'void'
attr(`VecChar_swap`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_swap`) = c("SWIGFunction", class('VecChar_swap'))

# Start of VecChar_clear

`VecChar_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecChar_clear`, 'returnType') = 'void'
attr(`VecChar_clear`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_clear`) = c("SWIGFunction", class('VecChar_clear'))

# Start of VecChar_get_allocator

`VecChar_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecChar_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_char_t", ref=ans);
  
  ans
  
}

attr(`VecChar_get_allocator`, 'returnType') = '_p_std__allocatorT_char_t'
attr(`VecChar_get_allocator`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_get_allocator`) = c("SWIGFunction", class('VecChar_get_allocator'))

# Start of new_VecChar

`VecChar__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecChar__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_2`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar__SWIG_2`, "inputTypes") = c('integer')
class(`VecChar__SWIG_2`) = c("SWIGFunction", class('VecChar__SWIG_2'))

# Start of VecChar_pop_back

`VecChar_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecChar_pop_back`, 'returnType') = 'void'
attr(`VecChar_pop_back`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_pop_back`) = c("SWIGFunction", class('VecChar_pop_back'))

# Start of VecChar_resize

`VecChar_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecChar_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecChar_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecChar_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar_resize__SWIG_0`) = c("SWIGFunction", class('VecChar_resize__SWIG_0'))

# Start of new_VecChar

`VecChar__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character");     
  ;ans = .Call('R_swig_new_VecChar__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_3`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar__SWIG_3`, "inputTypes") = c('integer', '_p_char')
class(`VecChar__SWIG_3`) = c("SWIGFunction", class('VecChar__SWIG_3'))

`VecChar` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecChar__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecChar__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_char_std__allocatorT_char_t_t') && length(argv[[1]]) == 1) {
      f <- VecChar__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_char') && length(argv[[2]]) == 1) {
      f <- VecChar__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecChar with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecChar_push_back

`VecChar_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_push_back`, 'returnType') = 'void'
attr(`VecChar_push_back`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', '_p_char')
class(`VecChar_push_back`) = c("SWIGFunction", class('VecChar_push_back'))

# Start of VecChar_front

`VecChar_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_front`, 'returnType') = '_p_char'
attr(`VecChar_front`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_front`) = c("SWIGFunction", class('VecChar_front'))

# Start of VecChar_back

`VecChar_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_back`, 'returnType') = '_p_char'
attr(`VecChar_back`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_back`) = c("SWIGFunction", class('VecChar_back'))

# Start of VecChar_assign

`VecChar_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_assign`, 'returnType') = 'void'
attr(`VecChar_assign`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', '_p_char')
class(`VecChar_assign`) = c("SWIGFunction", class('VecChar_assign'))

# Start of VecChar_resize

`VecChar_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecChar_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', '_p_char')
class(`VecChar_resize__SWIG_1`) = c("SWIGFunction", class('VecChar_resize__SWIG_1'))

`VecChar_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_char_std__allocatorT_char_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecChar_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_char_std__allocatorT_char_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_char') && length(argv[[3]]) == 1) {
      f <- VecChar_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecChar_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecChar_reserve

`VecChar_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecChar_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecChar_reserve`, 'returnType') = 'void'
attr(`VecChar_reserve`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar_reserve`) = c("SWIGFunction", class('VecChar_reserve'))

# Start of VecChar_capacity

`VecChar_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_capacity`, 'returnType') = 'integer'
attr(`VecChar_capacity`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_capacity`) = c("SWIGFunction", class('VecChar_capacity'))

# Start of delete_VecChar

`delete_VecChar` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecChar', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecChar`, 'returnType') = 'void'
attr(`delete_VecChar`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`delete_VecChar`) = c("SWIGFunction", class('delete_VecChar'))

# Start of accessor method for std::vector<(char)>
setMethod('$', '_p_std__vectorT_char_std__allocatorT_char_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecChar___nonzero__, '__len__' = VecChar___len__, 'pop' = VecChar_pop, '__getslice__' = VecChar___getslice__, '__setslice__' = VecChar___setslice__, '__delslice__' = VecChar___delslice__, '__delitem__' = VecChar___delitem__, '__getitem__' = VecChar___getitem__, '__setitem__' = VecChar___setitem__, 'append' = VecChar_append, 'empty' = VecChar_empty, 'size' = VecChar_size, 'swap' = VecChar_swap, 'clear' = VecChar_clear, 'get_allocator' = VecChar_get_allocator, 'pop_back' = VecChar_pop_back, 'resize' = VecChar_resize, 'push_back' = VecChar_push_back, 'front' = VecChar_front, 'back' = VecChar_back, 'assign' = VecChar_assign, 'reserve' = VecChar_reserve, 'capacity' = VecChar_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(char)>
setMethod('delete', '_p_std__vectorT_char_std__allocatorT_char_t_t', function(obj) {delete_std__vectorT_char_std__allocatorT_char_t_t(obj)})
# Start of VecVecDouble___nonzero__

`VecVecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecVecDouble___nonzero__`, "inputTypes") = c('list')
class(`VecVecDouble___nonzero__`) = c("SWIGFunction", class('VecVecDouble___nonzero__'))

# Start of VecVecDouble___len__

`VecVecDouble___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___len__`, 'returnType') = 'integer'
attr(`VecVecDouble___len__`, "inputTypes") = c('list')
class(`VecVecDouble___len__`) = c("SWIGFunction", class('VecVecDouble___len__'))

# Start of VecVecDouble_pop

`VecVecDouble_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_pop`, 'returnType') = 'numeric'
attr(`VecVecDouble_pop`, "inputTypes") = c('list')
class(`VecVecDouble_pop`) = c("SWIGFunction", class('VecVecDouble_pop'))

# Start of VecVecDouble___getslice__

`VecVecDouble___getslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___getslice__`, 'returnType') = 'list'
attr(`VecVecDouble___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___getslice__`) = c("SWIGFunction", class('VecVecDouble___getslice__'))

# Start of VecVecDouble___setslice__

`VecVecDouble___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___setslice__`, 'returnType') = 'void'
attr(`VecVecDouble___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecDouble___setslice__`) = c("SWIGFunction", class('VecVecDouble___setslice__'))

# Start of VecVecDouble___delslice__

`VecVecDouble___delslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___delslice__`, 'returnType') = 'void'
attr(`VecVecDouble___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___delslice__`) = c("SWIGFunction", class('VecVecDouble___delslice__'))

# Start of VecVecDouble___delitem__

`VecVecDouble___delitem__` = function(self, i)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___delitem__`, 'returnType') = 'void'
attr(`VecVecDouble___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___delitem__`) = c("SWIGFunction", class('VecVecDouble___delitem__'))

# Start of VecVecDouble___getitem__

`VecVecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___getitem__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___getitem__`) = c("SWIGFunction", class('VecVecDouble___getitem__'))

# Start of VecVecDouble___setitem__

`VecVecDouble___setitem__` = function(self, i, x)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___setitem__`, 'returnType') = 'void'
attr(`VecVecDouble___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble___setitem__`) = c("SWIGFunction", class('VecVecDouble___setitem__'))

# Start of VecVecDouble_append

`VecVecDouble_append` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_append`, 'returnType') = 'void'
attr(`VecVecDouble_append`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_append`) = c("SWIGFunction", class('VecVecDouble_append'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecDouble__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_0`, 'returnType') = 'list'
class(`VecVecDouble__SWIG_0`) = c("SWIGFunction", class('VecVecDouble__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_1` = function(other)
{
  other = lapply(other, as.numeric);
  ;.Call('R_swig_new_VecVecDouble__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_1`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_1`, "inputTypes") = c('list')
class(`VecVecDouble__SWIG_1`) = c("SWIGFunction", class('VecVecDouble__SWIG_1'))

# Start of VecVecDouble_empty

`VecVecDouble_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_empty`, 'returnType') = 'logical'
attr(`VecVecDouble_empty`, "inputTypes") = c('list')
class(`VecVecDouble_empty`) = c("SWIGFunction", class('VecVecDouble_empty'))

# Start of VecVecDouble_size

`VecVecDouble_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_size`, 'returnType') = 'integer'
attr(`VecVecDouble_size`, "inputTypes") = c('list')
class(`VecVecDouble_size`) = c("SWIGFunction", class('VecVecDouble_size'))

# Start of VecVecDouble_swap

`VecVecDouble_swap` = function(self, v)
{
  self = lapply(self, as.numeric);
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_swap`, 'returnType') = 'void'
attr(`VecVecDouble_swap`, "inputTypes") = c('list', 'list')
class(`VecVecDouble_swap`) = c("SWIGFunction", class('VecVecDouble_swap'))

# Start of VecVecDouble_clear

`VecVecDouble_clear` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_clear`, 'returnType') = 'void'
attr(`VecVecDouble_clear`, "inputTypes") = c('list')
class(`VecVecDouble_clear`) = c("SWIGFunction", class('VecVecDouble_clear'))

# Start of VecVecDouble_get_allocator

`VecVecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;ans = .Call('R_swig_VecVecDouble_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`VecVecDouble_get_allocator`, "inputTypes") = c('list')
class(`VecVecDouble_get_allocator`) = c("SWIGFunction", class('VecVecDouble_get_allocator'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecDouble__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_2`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecDouble__SWIG_2`) = c("SWIGFunction", class('VecVecDouble__SWIG_2'))

# Start of VecVecDouble_pop_back

`VecVecDouble_pop_back` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_pop_back`, 'returnType') = 'void'
attr(`VecVecDouble_pop_back`, "inputTypes") = c('list')
class(`VecVecDouble_pop_back`) = c("SWIGFunction", class('VecVecDouble_pop_back'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecDouble_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.numeric(value);
  ;.Call('R_swig_new_VecVecDouble__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_3`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble__SWIG_3`) = c("SWIGFunction", class('VecVecDouble__SWIG_3'))

`VecVecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecDouble__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) )) {
      f <- VecVecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_push_back

`VecVecDouble_push_back` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_push_back`, 'returnType') = 'void'
attr(`VecVecDouble_push_back`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_push_back`) = c("SWIGFunction", class('VecVecDouble_push_back'))

# Start of VecVecDouble_front

`VecVecDouble_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_front`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_front`, "inputTypes") = c('list')
class(`VecVecDouble_front`) = c("SWIGFunction", class('VecVecDouble_front'))

# Start of VecVecDouble_back

`VecVecDouble_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_back`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_back`, "inputTypes") = c('list')
class(`VecVecDouble_back`) = c("SWIGFunction", class('VecVecDouble_back'))

# Start of VecVecDouble_assign

`VecVecDouble_assign` = function(self, n, x)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_assign`, 'returnType') = 'void'
attr(`VecVecDouble_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_assign`) = c("SWIGFunction", class('VecVecDouble_assign'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_1'))

`VecVecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) )) {
      f <- VecVecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_reserve

`VecVecDouble_reserve` = function(self, n)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecDouble_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_reserve`, 'returnType') = 'void'
attr(`VecVecDouble_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_reserve`) = c("SWIGFunction", class('VecVecDouble_reserve'))

# Start of VecVecDouble_capacity

`VecVecDouble_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_capacity`, 'returnType') = 'integer'
attr(`VecVecDouble_capacity`, "inputTypes") = c('list')
class(`VecVecDouble_capacity`) = c("SWIGFunction", class('VecVecDouble_capacity'))

# Start of delete_VecVecDouble

`delete_VecVecDouble` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_delete_VecVecDouble', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecDouble`, 'returnType') = 'void'
attr(`delete_VecVecDouble`, "inputTypes") = c('list')
class(`delete_VecVecDouble`) = c("SWIGFunction", class('delete_VecVecDouble'))

# Start of accessor method for std::vector<(std::vector<(double)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecDouble___nonzero__, '__len__' = VecVecDouble___len__, 'pop' = VecVecDouble_pop, '__getslice__' = VecVecDouble___getslice__, '__setslice__' = VecVecDouble___setslice__, '__delslice__' = VecVecDouble___delslice__, '__delitem__' = VecVecDouble___delitem__, '__getitem__' = VecVecDouble___getitem__, '__setitem__' = VecVecDouble___setitem__, 'append' = VecVecDouble_append, 'empty' = VecVecDouble_empty, 'size' = VecVecDouble_size, 'swap' = VecVecDouble_swap, 'clear' = VecVecDouble_clear, 'get_allocator' = VecVecDouble_get_allocator, 'pop_back' = VecVecDouble_pop_back, 'resize' = VecVecDouble_resize, 'push_back' = VecVecDouble_push_back, 'front' = VecVecDouble_front, 'back' = VecVecDouble_back, 'assign' = VecVecDouble_assign, 'reserve' = VecVecDouble_reserve, 'capacity' = VecVecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(double)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t(obj)})
# Start of VecInt___nonzero__

`VecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecInt___nonzero__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___nonzero__`) = c("SWIGFunction", class('VecInt___nonzero__'))

# Start of VecInt___len__

`VecInt___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt___len__`, 'returnType') = 'integer'
attr(`VecInt___len__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___len__`) = c("SWIGFunction", class('VecInt___len__'))

# Start of VecInt_pop

`VecInt_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_pop`, 'returnType') = 'integer'
attr(`VecInt_pop`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop`) = c("SWIGFunction", class('VecInt_pop'))

# Start of VecInt___getslice__

`VecInt___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt___getslice__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt___getslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___getslice__`) = c("SWIGFunction", class('VecInt___getslice__'))

# Start of VecInt___setslice__

`VecInt___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecInt___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecInt___setslice__`, 'returnType') = 'void'
attr(`VecInt___setslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___setslice__`) = c("SWIGFunction", class('VecInt___setslice__'))

# Start of VecInt___delslice__

`VecInt___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt___delslice__`, 'returnType') = 'void'
attr(`VecInt___delslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___delslice__`) = c("SWIGFunction", class('VecInt___delslice__'))

# Start of VecInt___delitem__

`VecInt___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecInt___delitem__`, 'returnType') = 'void'
attr(`VecInt___delitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___delitem__`) = c("SWIGFunction", class('VecInt___delitem__'))

# Start of VecInt___getitem__

`VecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt___getitem__`, 'returnType') = 'integer'
attr(`VecInt___getitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___getitem__`) = c("SWIGFunction", class('VecInt___getitem__'))

# Start of VecInt___setitem__

`VecInt___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecInt___setitem__`, 'returnType') = 'void'
attr(`VecInt___setitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___setitem__`) = c("SWIGFunction", class('VecInt___setitem__'))

# Start of VecInt_append

`VecInt_append` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_append`, 'returnType') = 'void'
attr(`VecInt_append`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_append`) = c("SWIGFunction", class('VecInt_append'))

# Start of new_VecInt

`VecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecInt__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_0`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
class(`VecInt__SWIG_0`) = c("SWIGFunction", class('VecInt__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecInt__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_1`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt__SWIG_1`) = c("SWIGFunction", class('VecInt__SWIG_1'))

# Start of VecInt_empty

`VecInt_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_empty`, 'returnType') = 'logical'
attr(`VecInt_empty`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_empty`) = c("SWIGFunction", class('VecInt_empty'))

# Start of VecInt_size

`VecInt_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_size`, 'returnType') = 'integer'
attr(`VecInt_size`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_size`) = c("SWIGFunction", class('VecInt_size'))

# Start of VecInt_swap

`VecInt_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecInt_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecInt_swap`, 'returnType') = 'void'
attr(`VecInt_swap`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_swap`) = c("SWIGFunction", class('VecInt_swap'))

# Start of VecInt_clear

`VecInt_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecInt_clear`, 'returnType') = 'void'
attr(`VecInt_clear`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_clear`) = c("SWIGFunction", class('VecInt_clear'))

# Start of VecInt_get_allocator

`VecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecInt_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_int_t", ref=ans);
  
  ans
  
}

attr(`VecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_int_t'
attr(`VecInt_get_allocator`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_get_allocator`) = c("SWIGFunction", class('VecInt_get_allocator'))

# Start of new_VecInt

`VecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecInt__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_2`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecInt__SWIG_2`) = c("SWIGFunction", class('VecInt__SWIG_2'))

# Start of VecInt_pop_back

`VecInt_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecInt_pop_back`, 'returnType') = 'void'
attr(`VecInt_pop_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop_back`) = c("SWIGFunction", class('VecInt_pop_back'))

# Start of VecInt_resize

`VecInt_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecInt_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecInt_resize__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecInt__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_3`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecInt__SWIG_3`) = c("SWIGFunction", class('VecInt__SWIG_3'))

`VecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecInt__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_push_back

`VecInt_push_back` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_push_back`, 'returnType') = 'void'
attr(`VecInt_push_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_push_back`) = c("SWIGFunction", class('VecInt_push_back'))

# Start of VecInt_front

`VecInt_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_front`, 'returnType') = 'integer'
attr(`VecInt_front`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_front`) = c("SWIGFunction", class('VecInt_front'))

# Start of VecInt_back

`VecInt_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_back`, 'returnType') = 'integer'
attr(`VecInt_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_back`) = c("SWIGFunction", class('VecInt_back'))

# Start of VecInt_assign

`VecInt_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_assign`, 'returnType') = 'void'
attr(`VecInt_assign`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_assign`) = c("SWIGFunction", class('VecInt_assign'))

# Start of VecInt_resize

`VecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecInt_resize__SWIG_1'))

`VecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- VecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_reserve

`VecInt_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecInt_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecInt_reserve`, 'returnType') = 'void'
attr(`VecInt_reserve`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_reserve`) = c("SWIGFunction", class('VecInt_reserve'))

# Start of VecInt_capacity

`VecInt_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_capacity`, 'returnType') = 'integer'
attr(`VecInt_capacity`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_capacity`) = c("SWIGFunction", class('VecInt_capacity'))

# Start of delete_VecInt

`delete_VecInt` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecInt', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecInt`, 'returnType') = 'void'
attr(`delete_VecInt`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`delete_VecInt`) = c("SWIGFunction", class('delete_VecInt'))

# Start of accessor method for std::vector<(int)>
setMethod('$', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecInt___nonzero__, '__len__' = VecInt___len__, 'pop' = VecInt_pop, '__getslice__' = VecInt___getslice__, '__setslice__' = VecInt___setslice__, '__delslice__' = VecInt___delslice__, '__delitem__' = VecInt___delitem__, '__getitem__' = VecInt___getitem__, '__setitem__' = VecInt___setitem__, 'append' = VecInt_append, 'empty' = VecInt_empty, 'size' = VecInt_size, 'swap' = VecInt_swap, 'clear' = VecInt_clear, 'get_allocator' = VecInt_get_allocator, 'pop_back' = VecInt_pop_back, 'resize' = VecInt_resize, 'push_back' = VecInt_push_back, 'front' = VecInt_front, 'back' = VecInt_back, 'assign' = VecInt_assign, 'reserve' = VecInt_reserve, 'capacity' = VecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(int)>
setMethod('delete', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(obj) {delete_std__vectorT_int_std__allocatorT_int_t_t(obj)})
# Start of VecBool___nonzero__

`VecBool___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool___nonzero__`, 'returnType') = 'logical'
attr(`VecBool___nonzero__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool___nonzero__`) = c("SWIGFunction", class('VecBool___nonzero__'))

# Start of VecBool___len__

`VecBool___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool___len__`, 'returnType') = 'integer'
attr(`VecBool___len__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool___len__`) = c("SWIGFunction", class('VecBool___len__'))

# Start of VecBool_pop

`VecBool_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool_pop`, 'returnType') = 'logical'
attr(`VecBool_pop`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_pop`) = c("SWIGFunction", class('VecBool_pop'))

# Start of VecBool___getslice__

`VecBool___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecBool___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecBool___getslice__`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`VecBool___getslice__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`VecBool___getslice__`) = c("SWIGFunction", class('VecBool___getslice__'))

# Start of VecBool___setslice__

`VecBool___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.logical(v);
  ;.Call('R_swig_VecBool___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecBool___setslice__`, 'returnType') = 'void'
attr(`VecBool___setslice__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool___setslice__`) = c("SWIGFunction", class('VecBool___setslice__'))

# Start of VecBool___delslice__

`VecBool___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecBool___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecBool___delslice__`, 'returnType') = 'void'
attr(`VecBool___delslice__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`VecBool___delslice__`) = c("SWIGFunction", class('VecBool___delslice__'))

# Start of VecBool___delitem__

`VecBool___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecBool___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecBool___delitem__`, 'returnType') = 'void'
attr(`VecBool___delitem__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`VecBool___delitem__`) = c("SWIGFunction", class('VecBool___delitem__'))

# Start of VecBool___getitem__

`VecBool___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecBool___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool___getitem__`, 'returnType') = 'logical'
attr(`VecBool___getitem__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`VecBool___getitem__`) = c("SWIGFunction", class('VecBool___getitem__'))

# Start of VecBool___setitem__

`VecBool___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.logical(x);
  ;.Call('R_swig_VecBool___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecBool___setitem__`, 'returnType') = 'void'
attr(`VecBool___setitem__`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'logical')
class(`VecBool___setitem__`) = c("SWIGFunction", class('VecBool___setitem__'))

# Start of VecBool_append

`VecBool_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.logical(x);
  ;.Call('R_swig_VecBool_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecBool_append`, 'returnType') = 'void'
attr(`VecBool_append`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical')
class(`VecBool_append`) = c("SWIGFunction", class('VecBool_append'))

# Start of new_VecBool

`VecBool__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecBool__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecBool__SWIG_0`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
class(`VecBool__SWIG_0`) = c("SWIGFunction", class('VecBool__SWIG_0'))

# Start of new_VecBool

`VecBool__SWIG_1` = function(other)
{
  other = as.logical(other);
  ;.Call('R_swig_new_VecBool__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecBool__SWIG_1`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`VecBool__SWIG_1`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool__SWIG_1`) = c("SWIGFunction", class('VecBool__SWIG_1'))

# Start of VecBool_empty

`VecBool_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool_empty`, 'returnType') = 'logical'
attr(`VecBool_empty`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_empty`) = c("SWIGFunction", class('VecBool_empty'))

# Start of VecBool_size

`VecBool_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool_size`, 'returnType') = 'integer'
attr(`VecBool_size`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_size`) = c("SWIGFunction", class('VecBool_size'))

# Start of VecBool_swap

`VecBool_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  v = as.logical(v);
  ;.Call('R_swig_VecBool_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecBool_swap`, 'returnType') = 'void'
attr(`VecBool_swap`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_swap`) = c("SWIGFunction", class('VecBool_swap'))

# Start of VecBool_clear

`VecBool_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecBool_clear`, 'returnType') = 'void'
attr(`VecBool_clear`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_clear`) = c("SWIGFunction", class('VecBool_clear'))

# Start of VecBool_get_allocator

`VecBool_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecBool_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_bool_t", ref=ans);
  
  ans
  
}

attr(`VecBool_get_allocator`, 'returnType') = '_p_std__allocatorT_bool_t'
attr(`VecBool_get_allocator`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_get_allocator`) = c("SWIGFunction", class('VecBool_get_allocator'))

# Start of new_VecBool

`VecBool__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecBool__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecBool__SWIG_2`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`VecBool__SWIG_2`, "inputTypes") = c('integer')
class(`VecBool__SWIG_2`) = c("SWIGFunction", class('VecBool__SWIG_2'))

# Start of VecBool_pop_back

`VecBool_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecBool_pop_back`, 'returnType') = 'void'
attr(`VecBool_pop_back`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_pop_back`) = c("SWIGFunction", class('VecBool_pop_back'))

# Start of VecBool_resize

`VecBool_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecBool_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecBool_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecBool_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`VecBool_resize__SWIG_0`) = c("SWIGFunction", class('VecBool_resize__SWIG_0'))

# Start of new_VecBool

`VecBool__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.logical(value);
  ;.Call('R_swig_new_VecBool__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecBool__SWIG_3`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`VecBool__SWIG_3`, "inputTypes") = c('integer', 'logical')
class(`VecBool__SWIG_3`) = c("SWIGFunction", class('VecBool__SWIG_3'))

`VecBool` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecBool__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecBool__SWIG_2; 
    }
    else if (( is.logical(argv[[1]]) )) {
      f <- VecBool__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- VecBool__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecBool with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecBool_push_back

`VecBool_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.logical(x);
  ;.Call('R_swig_VecBool_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecBool_push_back`, 'returnType') = 'void'
attr(`VecBool_push_back`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'logical')
class(`VecBool_push_back`) = c("SWIGFunction", class('VecBool_push_back'))

# Start of VecBool_front

`VecBool_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool_front`, 'returnType') = 'logical'
attr(`VecBool_front`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_front`) = c("SWIGFunction", class('VecBool_front'))

# Start of VecBool_back

`VecBool_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool_back`, 'returnType') = 'logical'
attr(`VecBool_back`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_back`) = c("SWIGFunction", class('VecBool_back'))

# Start of VecBool_assign

`VecBool_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.logical(x);
  ;.Call('R_swig_VecBool_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecBool_assign`, 'returnType') = 'void'
attr(`VecBool_assign`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'logical')
class(`VecBool_assign`) = c("SWIGFunction", class('VecBool_assign'))

# Start of VecBool_resize

`VecBool_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.logical(x);
  ;.Call('R_swig_VecBool_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecBool_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecBool_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'logical')
class(`VecBool_resize__SWIG_1`) = c("SWIGFunction", class('VecBool_resize__SWIG_1'))

`VecBool_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.logical(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecBool_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.logical(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- VecBool_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecBool_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecBool_reserve

`VecBool_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecBool_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecBool_reserve`, 'returnType') = 'void'
attr(`VecBool_reserve`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`VecBool_reserve`) = c("SWIGFunction", class('VecBool_reserve'))

# Start of VecBool_capacity

`VecBool_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecBool_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecBool_capacity`, 'returnType') = 'integer'
attr(`VecBool_capacity`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`VecBool_capacity`) = c("SWIGFunction", class('VecBool_capacity'))

# Start of delete_VecBool

`delete_VecBool` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecBool', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecBool`, 'returnType') = 'void'
attr(`delete_VecBool`, "inputTypes") = c('_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`delete_VecBool`) = c("SWIGFunction", class('delete_VecBool'))

# Start of accessor method for std::vector<(bool)>
setMethod('$', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecBool___nonzero__, '__len__' = VecBool___len__, 'pop' = VecBool_pop, '__getslice__' = VecBool___getslice__, '__setslice__' = VecBool___setslice__, '__delslice__' = VecBool___delslice__, '__delitem__' = VecBool___delitem__, '__getitem__' = VecBool___getitem__, '__setitem__' = VecBool___setitem__, 'append' = VecBool_append, 'empty' = VecBool_empty, 'size' = VecBool_size, 'swap' = VecBool_swap, 'clear' = VecBool_clear, 'get_allocator' = VecBool_get_allocator, 'pop_back' = VecBool_pop_back, 'resize' = VecBool_resize, 'push_back' = VecBool_push_back, 'front' = VecBool_front, 'back' = VecBool_back, 'assign' = VecBool_assign, 'reserve' = VecBool_reserve, 'capacity' = VecBool_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(bool)>
setMethod('delete', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', function(obj) {delete_std__vectorT_bool_std__allocatorT_bool_t_t(obj)})
# Start of VecLong___nonzero__

`VecLong___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong___nonzero__`, 'returnType') = 'logical'
attr(`VecLong___nonzero__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong___nonzero__`) = c("SWIGFunction", class('VecLong___nonzero__'))

# Start of VecLong___len__

`VecLong___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong___len__`, 'returnType') = 'integer'
attr(`VecLong___len__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong___len__`) = c("SWIGFunction", class('VecLong___len__'))

# Start of VecLong_pop

`VecLong_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong_pop`, 'returnType') = 'integer'
attr(`VecLong_pop`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_pop`) = c("SWIGFunction", class('VecLong_pop'))

# Start of VecLong___getslice__

`VecLong___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecLong___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  ans
  
}

attr(`VecLong___getslice__`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
attr(`VecLong___getslice__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer', 'integer')
class(`VecLong___getslice__`) = c("SWIGFunction", class('VecLong___getslice__'))

# Start of VecLong___setslice__

`VecLong___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecLong___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecLong___setslice__`, 'returnType') = 'void'
attr(`VecLong___setslice__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer', 'integer', '_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong___setslice__`) = c("SWIGFunction", class('VecLong___setslice__'))

# Start of VecLong___delslice__

`VecLong___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecLong___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecLong___delslice__`, 'returnType') = 'void'
attr(`VecLong___delslice__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer', 'integer')
class(`VecLong___delslice__`) = c("SWIGFunction", class('VecLong___delslice__'))

# Start of VecLong___delitem__

`VecLong___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecLong___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecLong___delitem__`, 'returnType') = 'void'
attr(`VecLong___delitem__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer')
class(`VecLong___delitem__`) = c("SWIGFunction", class('VecLong___delitem__'))

# Start of VecLong___getitem__

`VecLong___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecLong___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong___getitem__`, 'returnType') = 'integer'
attr(`VecLong___getitem__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer')
class(`VecLong___getitem__`) = c("SWIGFunction", class('VecLong___getitem__'))

# Start of VecLong___setitem__

`VecLong___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecLong___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecLong___setitem__`, 'returnType') = 'void'
attr(`VecLong___setitem__`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer', 'integer')
class(`VecLong___setitem__`) = c("SWIGFunction", class('VecLong___setitem__'))

# Start of VecLong_append

`VecLong_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecLong_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecLong_append`, 'returnType') = 'void'
attr(`VecLong_append`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer')
class(`VecLong_append`) = c("SWIGFunction", class('VecLong_append'))

# Start of new_VecLong

`VecLong__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecLong__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecLong)
  ans
  
}

attr(`VecLong__SWIG_0`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
class(`VecLong__SWIG_0`) = c("SWIGFunction", class('VecLong__SWIG_0'))

# Start of new_VecLong

`VecLong__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecLong__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecLong)
  ans
  
}

attr(`VecLong__SWIG_1`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
attr(`VecLong__SWIG_1`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong__SWIG_1`) = c("SWIGFunction", class('VecLong__SWIG_1'))

# Start of VecLong_empty

`VecLong_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong_empty`, 'returnType') = 'logical'
attr(`VecLong_empty`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_empty`) = c("SWIGFunction", class('VecLong_empty'))

# Start of VecLong_size

`VecLong_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong_size`, 'returnType') = 'integer'
attr(`VecLong_size`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_size`) = c("SWIGFunction", class('VecLong_size'))

# Start of VecLong_swap

`VecLong_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecLong_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecLong_swap`, 'returnType') = 'void'
attr(`VecLong_swap`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', '_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_swap`) = c("SWIGFunction", class('VecLong_swap'))

# Start of VecLong_clear

`VecLong_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecLong_clear`, 'returnType') = 'void'
attr(`VecLong_clear`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_clear`) = c("SWIGFunction", class('VecLong_clear'))

# Start of VecLong_get_allocator

`VecLong_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecLong_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_long_t", ref=ans);
  
  ans
  
}

attr(`VecLong_get_allocator`, 'returnType') = '_p_std__allocatorT_long_t'
attr(`VecLong_get_allocator`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_get_allocator`) = c("SWIGFunction", class('VecLong_get_allocator'))

# Start of new_VecLong

`VecLong__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecLong__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecLong)
  ans
  
}

attr(`VecLong__SWIG_2`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
attr(`VecLong__SWIG_2`, "inputTypes") = c('integer')
class(`VecLong__SWIG_2`) = c("SWIGFunction", class('VecLong__SWIG_2'))

# Start of VecLong_pop_back

`VecLong_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecLong_pop_back`, 'returnType') = 'void'
attr(`VecLong_pop_back`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_pop_back`) = c("SWIGFunction", class('VecLong_pop_back'))

# Start of VecLong_resize

`VecLong_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecLong_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecLong_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecLong_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer')
class(`VecLong_resize__SWIG_0`) = c("SWIGFunction", class('VecLong_resize__SWIG_0'))

# Start of new_VecLong

`VecLong__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;ans = .Call('R_swig_new_VecLong__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecLong)
  ans
  
}

attr(`VecLong__SWIG_3`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
attr(`VecLong__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecLong__SWIG_3`) = c("SWIGFunction", class('VecLong__SWIG_3'))

`VecLong` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecLong__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecLong__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_long_std__allocatorT_long_t_t') && length(argv[[1]]) == 1) {
      f <- VecLong__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecLong__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecLong with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecLong_push_back

`VecLong_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecLong_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecLong_push_back`, 'returnType') = 'void'
attr(`VecLong_push_back`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer')
class(`VecLong_push_back`) = c("SWIGFunction", class('VecLong_push_back'))

# Start of VecLong_front

`VecLong_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong_front`, 'returnType') = 'integer'
attr(`VecLong_front`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_front`) = c("SWIGFunction", class('VecLong_front'))

# Start of VecLong_back

`VecLong_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong_back`, 'returnType') = 'integer'
attr(`VecLong_back`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_back`) = c("SWIGFunction", class('VecLong_back'))

# Start of VecLong_assign

`VecLong_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecLong_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecLong_assign`, 'returnType') = 'void'
attr(`VecLong_assign`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer', 'integer')
class(`VecLong_assign`) = c("SWIGFunction", class('VecLong_assign'))

# Start of VecLong_resize

`VecLong_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecLong_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecLong_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecLong_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer', 'integer')
class(`VecLong_resize__SWIG_1`) = c("SWIGFunction", class('VecLong_resize__SWIG_1'))

`VecLong_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_long_std__allocatorT_long_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecLong_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_long_std__allocatorT_long_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- VecLong_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecLong_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecLong_reserve

`VecLong_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecLong_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecLong_reserve`, 'returnType') = 'void'
attr(`VecLong_reserve`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t', 'integer')
class(`VecLong_reserve`) = c("SWIGFunction", class('VecLong_reserve'))

# Start of VecLong_capacity

`VecLong_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecLong_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecLong_capacity`, 'returnType') = 'integer'
attr(`VecLong_capacity`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`VecLong_capacity`) = c("SWIGFunction", class('VecLong_capacity'))

# Start of delete_VecLong

`delete_VecLong` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecLong', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecLong`, 'returnType') = 'void'
attr(`delete_VecLong`, "inputTypes") = c('_p_std__vectorT_long_std__allocatorT_long_t_t')
class(`delete_VecLong`) = c("SWIGFunction", class('delete_VecLong'))

# Start of accessor method for std::vector<(long)>
setMethod('$', '_p_std__vectorT_long_std__allocatorT_long_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecLong___nonzero__, '__len__' = VecLong___len__, 'pop' = VecLong_pop, '__getslice__' = VecLong___getslice__, '__setslice__' = VecLong___setslice__, '__delslice__' = VecLong___delslice__, '__delitem__' = VecLong___delitem__, '__getitem__' = VecLong___getitem__, '__setitem__' = VecLong___setitem__, 'append' = VecLong_append, 'empty' = VecLong_empty, 'size' = VecLong_size, 'swap' = VecLong_swap, 'clear' = VecLong_clear, 'get_allocator' = VecLong_get_allocator, 'pop_back' = VecLong_pop_back, 'resize' = VecLong_resize, 'push_back' = VecLong_push_back, 'front' = VecLong_front, 'back' = VecLong_back, 'assign' = VecLong_assign, 'reserve' = VecLong_reserve, 'capacity' = VecLong_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(long)>
setMethod('delete', '_p_std__vectorT_long_std__allocatorT_long_t_t', function(obj) {delete_std__vectorT_long_std__allocatorT_long_t_t(obj)})
# Start of VecInt64___nonzero__

`VecInt64___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64___nonzero__`, 'returnType') = 'logical'
attr(`VecInt64___nonzero__`, "inputTypes") = c('integer')
class(`VecInt64___nonzero__`) = c("SWIGFunction", class('VecInt64___nonzero__'))

# Start of VecInt64___len__

`VecInt64___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64___len__`, 'returnType') = 'integer'
attr(`VecInt64___len__`, "inputTypes") = c('integer')
class(`VecInt64___len__`) = c("SWIGFunction", class('VecInt64___len__'))

# Start of VecInt64_pop

`VecInt64_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_pop`, 'returnType') = 'integer'
attr(`VecInt64_pop`, "inputTypes") = c('integer')
class(`VecInt64_pop`) = c("SWIGFunction", class('VecInt64_pop'))

# Start of VecInt64___getslice__

`VecInt64___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt64___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt64___getslice__`, 'returnType') = 'integer'
attr(`VecInt64___getslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecInt64___getslice__`) = c("SWIGFunction", class('VecInt64___getslice__'))

# Start of VecInt64___setslice__

`VecInt64___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecInt64___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecInt64___setslice__`, 'returnType') = 'void'
attr(`VecInt64___setslice__`, "inputTypes") = c('integer', 'integer', 'integer', 'integer')
class(`VecInt64___setslice__`) = c("SWIGFunction", class('VecInt64___setslice__'))

# Start of VecInt64___delslice__

`VecInt64___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt64___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt64___delslice__`, 'returnType') = 'void'
attr(`VecInt64___delslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecInt64___delslice__`) = c("SWIGFunction", class('VecInt64___delslice__'))

# Start of VecInt64___delitem__

`VecInt64___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt64___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecInt64___delitem__`, 'returnType') = 'void'
attr(`VecInt64___delitem__`, "inputTypes") = c('integer', 'integer')
class(`VecInt64___delitem__`) = c("SWIGFunction", class('VecInt64___delitem__'))

# Start of VecInt64___getitem__

`VecInt64___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt64___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64___getitem__`, 'returnType') = '_p_long_long'
attr(`VecInt64___getitem__`, "inputTypes") = c('integer', 'integer')
class(`VecInt64___getitem__`) = c("SWIGFunction", class('VecInt64___getitem__'))

# Start of VecInt64___setitem__

`VecInt64___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64___setitem__`, 'returnType') = 'void'
attr(`VecInt64___setitem__`, "inputTypes") = c('integer', 'integer', '_p_long_long')
class(`VecInt64___setitem__`) = c("SWIGFunction", class('VecInt64___setitem__'))

# Start of VecInt64_append

`VecInt64_append` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_append`, 'returnType') = 'void'
attr(`VecInt64_append`, "inputTypes") = c('integer', '_p_long_long')
class(`VecInt64_append`) = c("SWIGFunction", class('VecInt64_append'))

# Start of new_VecInt64

`VecInt64__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecInt64__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_0`, 'returnType') = 'integer'
class(`VecInt64__SWIG_0`) = c("SWIGFunction", class('VecInt64__SWIG_0'))

# Start of new_VecInt64

`VecInt64__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecInt64__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_1`, 'returnType') = 'integer'
attr(`VecInt64__SWIG_1`, "inputTypes") = c('integer')
class(`VecInt64__SWIG_1`) = c("SWIGFunction", class('VecInt64__SWIG_1'))

# Start of VecInt64_empty

`VecInt64_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_empty`, 'returnType') = 'logical'
attr(`VecInt64_empty`, "inputTypes") = c('integer')
class(`VecInt64_empty`) = c("SWIGFunction", class('VecInt64_empty'))

# Start of VecInt64_size

`VecInt64_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_size`, 'returnType') = 'integer'
attr(`VecInt64_size`, "inputTypes") = c('integer')
class(`VecInt64_size`) = c("SWIGFunction", class('VecInt64_size'))

# Start of VecInt64_swap

`VecInt64_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecInt64_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecInt64_swap`, 'returnType') = 'void'
attr(`VecInt64_swap`, "inputTypes") = c('integer', 'integer')
class(`VecInt64_swap`) = c("SWIGFunction", class('VecInt64_swap'))

# Start of VecInt64_clear

`VecInt64_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecInt64_clear`, 'returnType') = 'void'
attr(`VecInt64_clear`, "inputTypes") = c('integer')
class(`VecInt64_clear`) = c("SWIGFunction", class('VecInt64_clear'))

# Start of VecInt64_get_allocator

`VecInt64_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecInt64_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_long_long_t", ref=ans);
  
  ans
  
}

attr(`VecInt64_get_allocator`, 'returnType') = '_p_std__allocatorT_long_long_t'
attr(`VecInt64_get_allocator`, "inputTypes") = c('integer')
class(`VecInt64_get_allocator`) = c("SWIGFunction", class('VecInt64_get_allocator'))

# Start of new_VecInt64

`VecInt64__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecInt64__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_2`, 'returnType') = 'integer'
attr(`VecInt64__SWIG_2`, "inputTypes") = c('integer')
class(`VecInt64__SWIG_2`) = c("SWIGFunction", class('VecInt64__SWIG_2'))

# Start of VecInt64_pop_back

`VecInt64_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecInt64_pop_back`, 'returnType') = 'void'
attr(`VecInt64_pop_back`, "inputTypes") = c('integer')
class(`VecInt64_pop_back`) = c("SWIGFunction", class('VecInt64_pop_back'))

# Start of VecInt64_resize

`VecInt64_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecInt64_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecInt64_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecInt64_resize__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`VecInt64_resize__SWIG_0`) = c("SWIGFunction", class('VecInt64_resize__SWIG_0'))

# Start of new_VecInt64

`VecInt64__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;.Call('R_swig_new_VecInt64__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_3`, 'returnType') = 'integer'
attr(`VecInt64__SWIG_3`, "inputTypes") = c('integer', '_p_long_long')
class(`VecInt64__SWIG_3`) = c("SWIGFunction", class('VecInt64__SWIG_3'))

`VecInt64` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecInt64__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecInt64__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecInt64__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_long_long') && length(argv[[2]]) == 1) {
      f <- VecInt64__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecInt64 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt64_push_back

`VecInt64_push_back` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_push_back`, 'returnType') = 'void'
attr(`VecInt64_push_back`, "inputTypes") = c('integer', '_p_long_long')
class(`VecInt64_push_back`) = c("SWIGFunction", class('VecInt64_push_back'))

# Start of VecInt64_front

`VecInt64_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_front`, 'returnType') = '_p_long_long'
attr(`VecInt64_front`, "inputTypes") = c('integer')
class(`VecInt64_front`) = c("SWIGFunction", class('VecInt64_front'))

# Start of VecInt64_back

`VecInt64_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_back`, 'returnType') = '_p_long_long'
attr(`VecInt64_back`, "inputTypes") = c('integer')
class(`VecInt64_back`) = c("SWIGFunction", class('VecInt64_back'))

# Start of VecInt64_assign

`VecInt64_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_assign`, 'returnType') = 'void'
attr(`VecInt64_assign`, "inputTypes") = c('integer', 'integer', '_p_long_long')
class(`VecInt64_assign`) = c("SWIGFunction", class('VecInt64_assign'))

# Start of VecInt64_resize

`VecInt64_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecInt64_resize__SWIG_1`, "inputTypes") = c('integer', 'integer', '_p_long_long')
class(`VecInt64_resize__SWIG_1`) = c("SWIGFunction", class('VecInt64_resize__SWIG_1'))

`VecInt64_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt64_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_long_long') && length(argv[[3]]) == 1) {
      f <- VecInt64_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecInt64_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt64_reserve

`VecInt64_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecInt64_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecInt64_reserve`, 'returnType') = 'void'
attr(`VecInt64_reserve`, "inputTypes") = c('integer', 'integer')
class(`VecInt64_reserve`) = c("SWIGFunction", class('VecInt64_reserve'))

# Start of VecInt64_capacity

`VecInt64_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_capacity`, 'returnType') = 'integer'
attr(`VecInt64_capacity`, "inputTypes") = c('integer')
class(`VecInt64_capacity`) = c("SWIGFunction", class('VecInt64_capacity'))

# Start of delete_VecInt64

`delete_VecInt64` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecInt64', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecInt64`, 'returnType') = 'void'
attr(`delete_VecInt64`, "inputTypes") = c('integer')
class(`delete_VecInt64`) = c("SWIGFunction", class('delete_VecInt64'))

# Start of accessor method for std::vector<(long long)>
setMethod('$', '_p_std__vectorT_long_long_std__allocatorT_long_long_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecInt64___nonzero__, '__len__' = VecInt64___len__, 'pop' = VecInt64_pop, '__getslice__' = VecInt64___getslice__, '__setslice__' = VecInt64___setslice__, '__delslice__' = VecInt64___delslice__, '__delitem__' = VecInt64___delitem__, '__getitem__' = VecInt64___getitem__, '__setitem__' = VecInt64___setitem__, 'append' = VecInt64_append, 'empty' = VecInt64_empty, 'size' = VecInt64_size, 'swap' = VecInt64_swap, 'clear' = VecInt64_clear, 'get_allocator' = VecInt64_get_allocator, 'pop_back' = VecInt64_pop_back, 'resize' = VecInt64_resize, 'push_back' = VecInt64_push_back, 'front' = VecInt64_front, 'back' = VecInt64_back, 'assign' = VecInt64_assign, 'reserve' = VecInt64_reserve, 'capacity' = VecInt64_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(long long)>
setMethod('delete', '_p_std__vectorT_long_long_std__allocatorT_long_long_t_t', function(obj) {delete_std__vectorT_long_long_std__allocatorT_long_long_t_t(obj)})
# Start of VecVecInt___nonzero__

`VecVecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecVecInt___nonzero__`, "inputTypes") = c('list')
class(`VecVecInt___nonzero__`) = c("SWIGFunction", class('VecVecInt___nonzero__'))

# Start of VecVecInt___len__

`VecVecInt___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt___len__`, 'returnType') = 'integer'
attr(`VecVecInt___len__`, "inputTypes") = c('list')
class(`VecVecInt___len__`) = c("SWIGFunction", class('VecVecInt___len__'))

# Start of VecVecInt_pop

`VecVecInt_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_pop`, 'returnType') = 'integer'
attr(`VecVecInt_pop`, "inputTypes") = c('list')
class(`VecVecInt_pop`) = c("SWIGFunction", class('VecVecInt_pop'))

# Start of VecVecInt___getslice__

`VecVecInt___getslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___getslice__`, 'returnType') = 'list'
attr(`VecVecInt___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___getslice__`) = c("SWIGFunction", class('VecVecInt___getslice__'))

# Start of VecVecInt___setslice__

`VecVecInt___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___setslice__`, 'returnType') = 'void'
attr(`VecVecInt___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecInt___setslice__`) = c("SWIGFunction", class('VecVecInt___setslice__'))

# Start of VecVecInt___delslice__

`VecVecInt___delslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___delslice__`, 'returnType') = 'void'
attr(`VecVecInt___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___delslice__`) = c("SWIGFunction", class('VecVecInt___delslice__'))

# Start of VecVecInt___delitem__

`VecVecInt___delitem__` = function(self, i)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___delitem__`, 'returnType') = 'void'
attr(`VecVecInt___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___delitem__`) = c("SWIGFunction", class('VecVecInt___delitem__'))

# Start of VecVecInt___getitem__

`VecVecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt___getitem__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___getitem__`) = c("SWIGFunction", class('VecVecInt___getitem__'))

# Start of VecVecInt___setitem__

`VecVecInt___setitem__` = function(self, i, x)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___setitem__`, 'returnType') = 'void'
attr(`VecVecInt___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt___setitem__`) = c("SWIGFunction", class('VecVecInt___setitem__'))

# Start of VecVecInt_append

`VecVecInt_append` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_append`, 'returnType') = 'void'
attr(`VecVecInt_append`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_append`) = c("SWIGFunction", class('VecVecInt_append'))

# Start of new_VecVecInt

`VecVecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecInt__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_0`, 'returnType') = 'list'
class(`VecVecInt__SWIG_0`) = c("SWIGFunction", class('VecVecInt__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_1` = function(other)
{
  other = lapply(other, as.integer);
  ;.Call('R_swig_new_VecVecInt__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_1`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_1`, "inputTypes") = c('list')
class(`VecVecInt__SWIG_1`) = c("SWIGFunction", class('VecVecInt__SWIG_1'))

# Start of VecVecInt_empty

`VecVecInt_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_empty`, 'returnType') = 'logical'
attr(`VecVecInt_empty`, "inputTypes") = c('list')
class(`VecVecInt_empty`) = c("SWIGFunction", class('VecVecInt_empty'))

# Start of VecVecInt_size

`VecVecInt_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_size`, 'returnType') = 'integer'
attr(`VecVecInt_size`, "inputTypes") = c('list')
class(`VecVecInt_size`) = c("SWIGFunction", class('VecVecInt_size'))

# Start of VecVecInt_swap

`VecVecInt_swap` = function(self, v)
{
  self = lapply(self, as.integer);
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_swap`, 'returnType') = 'void'
attr(`VecVecInt_swap`, "inputTypes") = c('list', 'list')
class(`VecVecInt_swap`) = c("SWIGFunction", class('VecVecInt_swap'))

# Start of VecVecInt_clear

`VecVecInt_clear` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_clear`, 'returnType') = 'void'
attr(`VecVecInt_clear`, "inputTypes") = c('list')
class(`VecVecInt_clear`) = c("SWIGFunction", class('VecVecInt_clear'))

# Start of VecVecInt_get_allocator

`VecVecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;ans = .Call('R_swig_VecVecInt_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t'
attr(`VecVecInt_get_allocator`, "inputTypes") = c('list')
class(`VecVecInt_get_allocator`) = c("SWIGFunction", class('VecVecInt_get_allocator'))

# Start of new_VecVecInt

`VecVecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecInt__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_2`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecInt__SWIG_2`) = c("SWIGFunction", class('VecVecInt__SWIG_2'))

# Start of VecVecInt_pop_back

`VecVecInt_pop_back` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_pop_back`, 'returnType') = 'void'
attr(`VecVecInt_pop_back`, "inputTypes") = c('list')
class(`VecVecInt_pop_back`) = c("SWIGFunction", class('VecVecInt_pop_back'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecInt_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecVecInt__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_3`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt__SWIG_3`) = c("SWIGFunction", class('VecVecInt__SWIG_3'))

`VecVecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecInt__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_push_back

`VecVecInt_push_back` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_push_back`, 'returnType') = 'void'
attr(`VecVecInt_push_back`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_push_back`) = c("SWIGFunction", class('VecVecInt_push_back'))

# Start of VecVecInt_front

`VecVecInt_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_front`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_front`, "inputTypes") = c('list')
class(`VecVecInt_front`) = c("SWIGFunction", class('VecVecInt_front'))

# Start of VecVecInt_back

`VecVecInt_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_back`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_back`, "inputTypes") = c('list')
class(`VecVecInt_back`) = c("SWIGFunction", class('VecVecInt_back'))

# Start of VecVecInt_assign

`VecVecInt_assign` = function(self, n, x)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_assign`, 'returnType') = 'void'
attr(`VecVecInt_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_assign`) = c("SWIGFunction", class('VecVecInt_assign'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_1'))

`VecVecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_reserve

`VecVecInt_reserve` = function(self, n)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecInt_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_reserve`, 'returnType') = 'void'
attr(`VecVecInt_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_reserve`) = c("SWIGFunction", class('VecVecInt_reserve'))

# Start of VecVecInt_capacity

`VecVecInt_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_capacity`, 'returnType') = 'integer'
attr(`VecVecInt_capacity`, "inputTypes") = c('list')
class(`VecVecInt_capacity`) = c("SWIGFunction", class('VecVecInt_capacity'))

# Start of delete_VecVecInt

`delete_VecVecInt` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_delete_VecVecInt', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecInt`, 'returnType') = 'void'
attr(`delete_VecVecInt`, "inputTypes") = c('list')
class(`delete_VecVecInt`) = c("SWIGFunction", class('delete_VecVecInt'))

# Start of accessor method for std::vector<(std::vector<(int)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecInt___nonzero__, '__len__' = VecVecInt___len__, 'pop' = VecVecInt_pop, '__getslice__' = VecVecInt___getslice__, '__setslice__' = VecVecInt___setslice__, '__delslice__' = VecVecInt___delslice__, '__delitem__' = VecVecInt___delitem__, '__getitem__' = VecVecInt___getitem__, '__setitem__' = VecVecInt___setitem__, 'append' = VecVecInt_append, 'empty' = VecVecInt_empty, 'size' = VecVecInt_size, 'swap' = VecVecInt_swap, 'clear' = VecVecInt_clear, 'get_allocator' = VecVecInt_get_allocator, 'pop_back' = VecVecInt_pop_back, 'resize' = VecVecInt_resize, 'push_back' = VecVecInt_push_back, 'front' = VecVecInt_front, 'back' = VecVecInt_back, 'assign' = VecVecInt_assign, 'reserve' = VecVecInt_reserve, 'capacity' = VecVecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(int)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t(obj)})
# Start of VecUINT8___nonzero__

`VecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecUINT8___nonzero__`, "inputTypes") = c('integer')
class(`VecUINT8___nonzero__`) = c("SWIGFunction", class('VecUINT8___nonzero__'))

# Start of VecUINT8___len__

`VecUINT8___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8___len__`, 'returnType') = 'integer'
attr(`VecUINT8___len__`, "inputTypes") = c('integer')
class(`VecUINT8___len__`) = c("SWIGFunction", class('VecUINT8___len__'))

# Start of VecUINT8_pop

`VecUINT8_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_pop`, 'returnType') = 'integer'
attr(`VecUINT8_pop`, "inputTypes") = c('integer')
class(`VecUINT8_pop`) = c("SWIGFunction", class('VecUINT8_pop'))

# Start of VecUINT8___getslice__

`VecUINT8___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___getslice__`, 'returnType') = 'integer'
attr(`VecUINT8___getslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___getslice__`) = c("SWIGFunction", class('VecUINT8___getslice__'))

# Start of VecUINT8___setslice__

`VecUINT8___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecUINT8___setslice__`, "inputTypes") = c('integer', 'integer', 'integer', 'integer')
class(`VecUINT8___setslice__`) = c("SWIGFunction", class('VecUINT8___setslice__'))

# Start of VecUINT8___delslice__

`VecUINT8___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecUINT8___delslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___delslice__`) = c("SWIGFunction", class('VecUINT8___delslice__'))

# Start of VecUINT8___delitem__

`VecUINT8___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecUINT8___delitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___delitem__`) = c("SWIGFunction", class('VecUINT8___delitem__'))

# Start of VecUINT8___getitem__

`VecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8___getitem__`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8___getitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___getitem__`) = c("SWIGFunction", class('VecUINT8___getitem__'))

# Start of VecUINT8___setitem__

`VecUINT8___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecUINT8___setitem__`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8___setitem__`) = c("SWIGFunction", class('VecUINT8___setitem__'))

# Start of VecUINT8_append

`VecUINT8_append` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_append`, 'returnType') = 'void'
attr(`VecUINT8_append`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_append`) = c("SWIGFunction", class('VecUINT8_append'))

# Start of new_VecUINT8

`VecUINT8__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecUINT8__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_0`, 'returnType') = 'integer'
class(`VecUINT8__SWIG_0`) = c("SWIGFunction", class('VecUINT8__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecUINT8__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_1`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_1`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_1`) = c("SWIGFunction", class('VecUINT8__SWIG_1'))

# Start of VecUINT8_empty

`VecUINT8_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_empty`, 'returnType') = 'logical'
attr(`VecUINT8_empty`, "inputTypes") = c('integer')
class(`VecUINT8_empty`) = c("SWIGFunction", class('VecUINT8_empty'))

# Start of VecUINT8_size

`VecUINT8_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_size`, 'returnType') = 'integer'
attr(`VecUINT8_size`, "inputTypes") = c('integer')
class(`VecUINT8_size`) = c("SWIGFunction", class('VecUINT8_size'))

# Start of VecUINT8_swap

`VecUINT8_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_swap`, 'returnType') = 'void'
attr(`VecUINT8_swap`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_swap`) = c("SWIGFunction", class('VecUINT8_swap'))

# Start of VecUINT8_clear

`VecUINT8_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_clear`, 'returnType') = 'void'
attr(`VecUINT8_clear`, "inputTypes") = c('integer')
class(`VecUINT8_clear`) = c("SWIGFunction", class('VecUINT8_clear'))

# Start of VecUINT8_get_allocator

`VecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_unsigned_char_t", ref=ans);
  
  ans
  
}

attr(`VecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_char_t'
attr(`VecUINT8_get_allocator`, "inputTypes") = c('integer')
class(`VecUINT8_get_allocator`) = c("SWIGFunction", class('VecUINT8_get_allocator'))

# Start of new_VecUINT8

`VecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecUINT8__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_2`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_2`) = c("SWIGFunction", class('VecUINT8__SWIG_2'))

# Start of VecUINT8_pop_back

`VecUINT8_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecUINT8_pop_back`, "inputTypes") = c('integer')
class(`VecUINT8_pop_back`) = c("SWIGFunction", class('VecUINT8_pop_back'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecUINT8_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;.Call('R_swig_new_VecUINT8__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_3`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8__SWIG_3`) = c("SWIGFunction", class('VecUINT8__SWIG_3'))

`VecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecUINT8__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_unsigned_char') && length(argv[[2]]) == 1) {
      f <- VecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_push_back

`VecUINT8_push_back` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_push_back`, 'returnType') = 'void'
attr(`VecUINT8_push_back`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_push_back`) = c("SWIGFunction", class('VecUINT8_push_back'))

# Start of VecUINT8_front

`VecUINT8_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_front`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_front`, "inputTypes") = c('integer')
class(`VecUINT8_front`) = c("SWIGFunction", class('VecUINT8_front'))

# Start of VecUINT8_back

`VecUINT8_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_back`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_back`, "inputTypes") = c('integer')
class(`VecUINT8_back`) = c("SWIGFunction", class('VecUINT8_back'))

# Start of VecUINT8_assign

`VecUINT8_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_assign`, 'returnType') = 'void'
attr(`VecUINT8_assign`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_assign`) = c("SWIGFunction", class('VecUINT8_assign'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_1`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_1'))

`VecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_unsigned_char') && length(argv[[3]]) == 1) {
      f <- VecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_reserve

`VecUINT8_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecUINT8_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_reserve`, 'returnType') = 'void'
attr(`VecUINT8_reserve`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_reserve`) = c("SWIGFunction", class('VecUINT8_reserve'))

# Start of VecUINT8_capacity

`VecUINT8_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecUINT8_capacity`, "inputTypes") = c('integer')
class(`VecUINT8_capacity`) = c("SWIGFunction", class('VecUINT8_capacity'))

# Start of delete_VecUINT8

`delete_VecUINT8` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecUINT8', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecUINT8`, 'returnType') = 'void'
attr(`delete_VecUINT8`, "inputTypes") = c('integer')
class(`delete_VecUINT8`) = c("SWIGFunction", class('delete_VecUINT8'))

# Start of accessor method for std::vector<(unsigned char)>
setMethod('$', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecUINT8___nonzero__, '__len__' = VecUINT8___len__, 'pop' = VecUINT8_pop, '__getslice__' = VecUINT8___getslice__, '__setslice__' = VecUINT8___setslice__, '__delslice__' = VecUINT8___delslice__, '__delitem__' = VecUINT8___delitem__, '__getitem__' = VecUINT8___getitem__, '__setitem__' = VecUINT8___setitem__, 'append' = VecUINT8_append, 'empty' = VecUINT8_empty, 'size' = VecUINT8_size, 'swap' = VecUINT8_swap, 'clear' = VecUINT8_clear, 'get_allocator' = VecUINT8_get_allocator, 'pop_back' = VecUINT8_pop_back, 'resize' = VecUINT8_resize, 'push_back' = VecUINT8_push_back, 'front' = VecUINT8_front, 'back' = VecUINT8_back, 'assign' = VecUINT8_assign, 'reserve' = VecUINT8_reserve, 'capacity' = VecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(unsigned char)>
setMethod('delete', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(obj) {delete_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t(obj)})
# Start of VecVecUINT8___nonzero__

`VecVecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecVecUINT8___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___nonzero__`) = c("SWIGFunction", class('VecVecUINT8___nonzero__'))

# Start of VecVecUINT8___len__

`VecVecUINT8___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___len__`, 'returnType') = 'integer'
attr(`VecVecUINT8___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___len__`) = c("SWIGFunction", class('VecVecUINT8___len__'))

# Start of VecVecUINT8_pop

`VecVecUINT8_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_pop`, 'returnType') = 'integer'
attr(`VecVecUINT8_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop`) = c("SWIGFunction", class('VecVecUINT8_pop'))

# Start of VecVecUINT8___getslice__

`VecVecUINT8___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVecUINT8___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecUINT8___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___getslice__`) = c("SWIGFunction", class('VecVecUINT8___getslice__'))

# Start of VecVecUINT8___setslice__

`VecVecUINT8___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___setslice__`) = c("SWIGFunction", class('VecVecUINT8___setslice__'))

# Start of VecVecUINT8___delslice__

`VecVecUINT8___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecUINT8___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___delslice__`) = c("SWIGFunction", class('VecVecUINT8___delslice__'))

# Start of VecVecUINT8___delitem__

`VecVecUINT8___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___delitem__`) = c("SWIGFunction", class('VecVecUINT8___delitem__'))

# Start of VecVecUINT8___getitem__

`VecVecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___getitem__`, 'returnType') = 'integer'
attr(`VecVecUINT8___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___getitem__`) = c("SWIGFunction", class('VecVecUINT8___getitem__'))

# Start of VecVecUINT8___setitem__

`VecVecUINT8___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___setitem__`) = c("SWIGFunction", class('VecVecUINT8___setitem__'))

# Start of VecVecUINT8_append

`VecVecUINT8_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_append`, 'returnType') = 'void'
attr(`VecVecUINT8_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_append`) = c("SWIGFunction", class('VecVecUINT8_append'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
class(`VecVecUINT8__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8__SWIG_1'))

# Start of VecVecUINT8_empty

`VecVecUINT8_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_empty`, 'returnType') = 'logical'
attr(`VecVecUINT8_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_empty`) = c("SWIGFunction", class('VecVecUINT8_empty'))

# Start of VecVecUINT8_size

`VecVecUINT8_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_size`, 'returnType') = 'integer'
attr(`VecVecUINT8_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_size`) = c("SWIGFunction", class('VecVecUINT8_size'))

# Start of VecVecUINT8_swap

`VecVecUINT8_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_swap`, 'returnType') = 'void'
attr(`VecVecUINT8_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_swap`) = c("SWIGFunction", class('VecVecUINT8_swap'))

# Start of VecVecUINT8_clear

`VecVecUINT8_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_clear`, 'returnType') = 'void'
attr(`VecVecUINT8_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_clear`) = c("SWIGFunction", class('VecVecUINT8_clear'))

# Start of VecVecUINT8_get_allocator

`VecVecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t'
attr(`VecVecUINT8_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_get_allocator`) = c("SWIGFunction", class('VecVecUINT8_get_allocator'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecUINT8__SWIG_2`) = c("SWIGFunction", class('VecVecUINT8__SWIG_2'))

# Start of VecVecUINT8_pop_back

`VecVecUINT8_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecVecUINT8_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop_back`) = c("SWIGFunction", class('VecVecUINT8_pop_back'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecVecUINT8__SWIG_3`) = c("SWIGFunction", class('VecVecUINT8__SWIG_3'))

`VecVecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecUINT8__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- VecVecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_push_back

`VecVecUINT8_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_push_back`, 'returnType') = 'void'
attr(`VecVecUINT8_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_push_back`) = c("SWIGFunction", class('VecVecUINT8_push_back'))

# Start of VecVecUINT8_front

`VecVecUINT8_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_front`, 'returnType') = 'integer'
attr(`VecVecUINT8_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_front`) = c("SWIGFunction", class('VecVecUINT8_front'))

# Start of VecVecUINT8_back

`VecVecUINT8_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_back`, 'returnType') = 'integer'
attr(`VecVecUINT8_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_back`) = c("SWIGFunction", class('VecVecUINT8_back'))

# Start of VecVecUINT8_assign

`VecVecUINT8_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_assign`, 'returnType') = 'void'
attr(`VecVecUINT8_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_assign`) = c("SWIGFunction", class('VecVecUINT8_assign'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_1'))

`VecVecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_reserve

`VecVecUINT8_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecUINT8_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_reserve`, 'returnType') = 'void'
attr(`VecVecUINT8_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_reserve`) = c("SWIGFunction", class('VecVecUINT8_reserve'))

# Start of VecVecUINT8_capacity

`VecVecUINT8_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecVecUINT8_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_capacity`) = c("SWIGFunction", class('VecVecUINT8_capacity'))

# Start of delete_VecVecUINT8

`delete_VecVecUINT8` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVecUINT8', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecUINT8`, 'returnType') = 'void'
attr(`delete_VecVecUINT8`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`delete_VecVecUINT8`) = c("SWIGFunction", class('delete_VecVecUINT8'))

# Start of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecUINT8___nonzero__, '__len__' = VecVecUINT8___len__, 'pop' = VecVecUINT8_pop, '__getslice__' = VecVecUINT8___getslice__, '__setslice__' = VecVecUINT8___setslice__, '__delslice__' = VecVecUINT8___delslice__, '__delitem__' = VecVecUINT8___delitem__, '__getitem__' = VecVecUINT8___getitem__, '__setitem__' = VecVecUINT8___setitem__, 'append' = VecVecUINT8_append, 'empty' = VecVecUINT8_empty, 'size' = VecVecUINT8_size, 'swap' = VecVecUINT8_swap, 'clear' = VecVecUINT8_clear, 'get_allocator' = VecVecUINT8_get_allocator, 'pop_back' = VecVecUINT8_pop_back, 'resize' = VecVecUINT8_resize, 'push_back' = VecVecUINT8_push_back, 'front' = VecVecUINT8_front, 'back' = VecVecUINT8_back, 'assign' = VecVecUINT8_assign, 'reserve' = VecVecUINT8_reserve, 'capacity' = VecVecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t(obj)})
# Start of VecVecChar___nonzero__

`VecVecChar___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar___nonzero__`, 'returnType') = 'logical'
attr(`VecVecChar___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar___nonzero__`) = c("SWIGFunction", class('VecVecChar___nonzero__'))

# Start of VecVecChar___len__

`VecVecChar___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar___len__`, 'returnType') = 'integer'
attr(`VecVecChar___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar___len__`) = c("SWIGFunction", class('VecVecChar___len__'))

# Start of VecVecChar_pop

`VecVecChar_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_pop`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_pop`) = c("SWIGFunction", class('VecVecChar_pop'))

# Start of VecVecChar___getslice__

`VecVecChar___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVecChar___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', 'integer')
class(`VecVecChar___getslice__`) = c("SWIGFunction", class('VecVecChar___getslice__'))

# Start of VecVecChar___setslice__

`VecVecChar___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecChar___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___setslice__`, 'returnType') = 'void'
attr(`VecVecChar___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar___setslice__`) = c("SWIGFunction", class('VecVecChar___setslice__'))

# Start of VecVecChar___delslice__

`VecVecChar___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecChar___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___delslice__`, 'returnType') = 'void'
attr(`VecVecChar___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', 'integer')
class(`VecVecChar___delslice__`) = c("SWIGFunction", class('VecVecChar___delslice__'))

# Start of VecVecChar___delitem__

`VecVecChar___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecChar___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___delitem__`, 'returnType') = 'void'
attr(`VecVecChar___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar___delitem__`) = c("SWIGFunction", class('VecVecChar___delitem__'))

# Start of VecVecChar___getitem__

`VecVecChar___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_VecVecChar___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar___getitem__`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar___getitem__`) = c("SWIGFunction", class('VecVecChar___getitem__'))

# Start of VecVecChar___setitem__

`VecVecChar___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___setitem__`, 'returnType') = 'void'
attr(`VecVecChar___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar___setitem__`) = c("SWIGFunction", class('VecVecChar___setitem__'))

# Start of VecVecChar_append

`VecVecChar_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_append`, 'returnType') = 'void'
attr(`VecVecChar_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_append`) = c("SWIGFunction", class('VecVecChar_append'))

# Start of new_VecVecChar

`VecVecChar__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
class(`VecVecChar__SWIG_0`) = c("SWIGFunction", class('VecVecChar__SWIG_0'))

# Start of new_VecVecChar

`VecVecChar__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar__SWIG_1`) = c("SWIGFunction", class('VecVecChar__SWIG_1'))

# Start of VecVecChar_empty

`VecVecChar_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar_empty`, 'returnType') = 'logical'
attr(`VecVecChar_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_empty`) = c("SWIGFunction", class('VecVecChar_empty'))

# Start of VecVecChar_size

`VecVecChar_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar_size`, 'returnType') = 'integer'
attr(`VecVecChar_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_size`) = c("SWIGFunction", class('VecVecChar_size'))

# Start of VecVecChar_swap

`VecVecChar_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecChar_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_swap`, 'returnType') = 'void'
attr(`VecVecChar_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_swap`) = c("SWIGFunction", class('VecVecChar_swap'))

# Start of VecVecChar_clear

`VecVecChar_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_clear`, 'returnType') = 'void'
attr(`VecVecChar_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_clear`) = c("SWIGFunction", class('VecVecChar_clear'))

# Start of VecVecChar_get_allocator

`VecVecChar_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t'
attr(`VecVecChar_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_get_allocator`) = c("SWIGFunction", class('VecVecChar_get_allocator'))

# Start of new_VecVecChar

`VecVecChar__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecChar__SWIG_2`) = c("SWIGFunction", class('VecVecChar__SWIG_2'))

# Start of VecVecChar_pop_back

`VecVecChar_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_pop_back`, 'returnType') = 'void'
attr(`VecVecChar_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_pop_back`) = c("SWIGFunction", class('VecVecChar_pop_back'))

# Start of VecVecChar_resize

`VecVecChar_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecChar_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecChar_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar_resize__SWIG_0`) = c("SWIGFunction", class('VecVecChar_resize__SWIG_0'))

# Start of new_VecVecChar

`VecVecChar__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar__SWIG_3`) = c("SWIGFunction", class('VecVecChar__SWIG_3'))

`VecVecChar` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecChar__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecChar__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- VecVecChar__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_std__vectorT_char_std__allocatorT_char_t_t') && length(argv[[2]]) == 1) {
      f <- VecVecChar__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecChar with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecChar_push_back

`VecVecChar_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_push_back`, 'returnType') = 'void'
attr(`VecVecChar_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_push_back`) = c("SWIGFunction", class('VecVecChar_push_back'))

# Start of VecVecChar_front

`VecVecChar_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_front', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_front`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_front`) = c("SWIGFunction", class('VecVecChar_front'))

# Start of VecVecChar_back

`VecVecChar_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_back', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_back`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_back`) = c("SWIGFunction", class('VecVecChar_back'))

# Start of VecVecChar_assign

`VecVecChar_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_assign`, 'returnType') = 'void'
attr(`VecVecChar_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_assign`) = c("SWIGFunction", class('VecVecChar_assign'))

# Start of VecVecChar_resize

`VecVecChar_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecChar_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_resize__SWIG_1`) = c("SWIGFunction", class('VecVecChar_resize__SWIG_1'))

`VecVecChar_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecChar_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_std__vectorT_char_std__allocatorT_char_t_t') && length(argv[[3]]) == 1) {
      f <- VecVecChar_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecChar_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecChar_reserve

`VecVecChar_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecChar_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_reserve`, 'returnType') = 'void'
attr(`VecVecChar_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar_reserve`) = c("SWIGFunction", class('VecVecChar_reserve'))

# Start of VecVecChar_capacity

`VecVecChar_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar_capacity`, 'returnType') = 'integer'
attr(`VecVecChar_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_capacity`) = c("SWIGFunction", class('VecVecChar_capacity'))

# Start of delete_VecVecChar

`delete_VecVecChar` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVecChar', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecChar`, 'returnType') = 'void'
attr(`delete_VecVecChar`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`delete_VecVecChar`) = c("SWIGFunction", class('delete_VecVecChar'))

# Start of accessor method for std::vector<(std::vector<(char)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecChar___nonzero__, '__len__' = VecVecChar___len__, 'pop' = VecVecChar_pop, '__getslice__' = VecVecChar___getslice__, '__setslice__' = VecVecChar___setslice__, '__delslice__' = VecVecChar___delslice__, '__delitem__' = VecVecChar___delitem__, '__getitem__' = VecVecChar___getitem__, '__setitem__' = VecVecChar___setitem__, 'append' = VecVecChar_append, 'empty' = VecVecChar_empty, 'size' = VecVecChar_size, 'swap' = VecVecChar_swap, 'clear' = VecVecChar_clear, 'get_allocator' = VecVecChar_get_allocator, 'pop_back' = VecVecChar_pop_back, 'resize' = VecVecChar_resize, 'push_back' = VecVecChar_push_back, 'front' = VecVecChar_front, 'back' = VecVecChar_back, 'assign' = VecVecChar_assign, 'reserve' = VecVecChar_reserve, 'capacity' = VecVecChar_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(char)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t(obj)})
# Start of delete_GeoDaWeight

`delete_GeoDaWeight` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaWeight', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaWeight`, 'returnType') = 'void'
attr(`delete_GeoDaWeight`, "inputTypes") = c('_p_GeoDaWeight')
class(`delete_GeoDaWeight`) = c("SWIGFunction", class('delete_GeoDaWeight'))

# Start of GeoDaWeight_CheckNeighbor

`GeoDaWeight_CheckNeighbor` = function(self, obs_idx, nbr_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  nbr_idx = as.integer(nbr_idx);
  
  if(length(nbr_idx) > 1) {
    warning("using only the first element of nbr_idx");
  };
  
  ;.Call('R_swig_GeoDaWeight_CheckNeighbor', self, obs_idx, nbr_idx, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_CheckNeighbor`, 'returnType') = 'logical'
attr(`GeoDaWeight_CheckNeighbor`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer')
class(`GeoDaWeight_CheckNeighbor`) = c("SWIGFunction", class('GeoDaWeight_CheckNeighbor'))

# Start of GeoDaWeight_GetNeighbors

`GeoDaWeight_GetNeighbors` = function(self, obs_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  ;ans = .Call('R_swig_GeoDaWeight_GetNeighbors', self, obs_idx, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_GetNeighbors`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
attr(`GeoDaWeight_GetNeighbors`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_GetNeighbors`) = c("SWIGFunction", class('GeoDaWeight_GetNeighbors'))

# Start of GeoDaWeight_GetNeighborWeights

`GeoDaWeight_GetNeighborWeights` = function(self, obs_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  ;.Call('R_swig_GeoDaWeight_GetNeighborWeights', self, obs_idx, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetNeighborWeights`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetNeighborWeights`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_GetNeighborWeights`) = c("SWIGFunction", class('GeoDaWeight_GetNeighborWeights'))

# Start of GeoDaWeight_Update

`GeoDaWeight_Update` = function(self, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  undefs = as.logical(undefs);
  ;.Call('R_swig_GeoDaWeight_Update', self, undefs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_Update`, 'returnType') = 'void'
attr(`GeoDaWeight_Update`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDaWeight_Update`) = c("SWIGFunction", class('GeoDaWeight_Update'))

# Start of GeoDaWeight_HasIsolates

`GeoDaWeight_HasIsolates` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_HasIsolates', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_HasIsolates`, 'returnType') = 'logical'
attr(`GeoDaWeight_HasIsolates`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_HasIsolates`) = c("SWIGFunction", class('GeoDaWeight_HasIsolates'))

# Start of GeoDaWeight_GetNbrStats

`GeoDaWeight_GetNbrStats` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetNbrStats', self, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetNbrStats`, 'returnType') = 'void'
attr(`GeoDaWeight_GetNbrStats`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetNbrStats`) = c("SWIGFunction", class('GeoDaWeight_GetNbrStats'))

# Start of GeoDaWeight_GetNbrSize

`GeoDaWeight_GetNbrSize` = function(self, obs_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  ;.Call('R_swig_GeoDaWeight_GetNbrSize', self, obs_idx, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetNbrSize`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetNbrSize`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_GetNbrSize`) = c("SWIGFunction", class('GeoDaWeight_GetNbrSize'))

# Start of GeoDaWeight_SpatialLag

`GeoDaWeight_SpatialLag` = function(self, obs_idx, data, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  data = as.numeric(data);
  ;.Call('R_swig_GeoDaWeight_SpatialLag', self, obs_idx, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_SpatialLag`, 'returnType') = 'numeric'
attr(`GeoDaWeight_SpatialLag`, "inputTypes") = c('_p_GeoDaWeight', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaWeight_SpatialLag`) = c("SWIGFunction", class('GeoDaWeight_SpatialLag'))

# Start of GeoDaWeight_Save

`GeoDaWeight_Save__SWIG_0` = function(self, ofname, layer_name, id_var_name, id_vec, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ofname = as(ofname, "character"); 
  layer_name = as(layer_name, "character"); 
  id_var_name = as(id_var_name, "character"); 
  id_vec = as.integer(id_vec);
  ;.Call('R_swig_GeoDaWeight_Save__SWIG_0', self, ofname, layer_name, id_var_name, id_vec, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_Save__SWIG_0`, 'returnType') = 'logical'
attr(`GeoDaWeight_Save__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', 'character', 'character', 'character', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`GeoDaWeight_Save__SWIG_0`) = c("SWIGFunction", class('GeoDaWeight_Save__SWIG_0'))

# Start of GeoDaWeight_Save

`GeoDaWeight_Save__SWIG_1` = function(self, ofname, layer_name, id_var_name, id_vec, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ofname = as(ofname, "character"); 
  layer_name = as(layer_name, "character"); 
  id_var_name = as(id_var_name, "character"); 
  if (inherits(id_vec, "ExternalReference")) id_vec = slot(id_vec,"ref") 
  ;.Call('R_swig_GeoDaWeight_Save__SWIG_1', self, ofname, layer_name, id_var_name, id_vec, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_Save__SWIG_1`, 'returnType') = 'logical'
attr(`GeoDaWeight_Save__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', 'character', 'character', 'character', '_p_std__vectorT_char_const_p_std__allocatorT_char_const_p_t_t')
class(`GeoDaWeight_Save__SWIG_1`) = c("SWIGFunction", class('GeoDaWeight_Save__SWIG_1'))

`GeoDaWeight_Save` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && is.character(argv[[2]]) && is.character(argv[[3]]) && is.character(argv[[4]]) && extends(argtypes[5], '_p_std__vectorT_char_const_p_std__allocatorT_char_const_p_t_t') && length(argv[[5]]) == 1) {
      f <- GeoDaWeight_Save__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && is.character(argv[[2]]) && is.character(argv[[3]]) && is.character(argv[[4]]) && ( is.integer(argv[[5]]) || is.numeric(argv[[5]]) )) {
      f <- GeoDaWeight_Save__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaWeight_Save with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaWeight_GetSparsity

`GeoDaWeight_GetSparsity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetSparsity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetSparsity`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetSparsity`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetSparsity`) = c("SWIGFunction", class('GeoDaWeight_GetSparsity'))

# Start of GeoDaWeight_GetDensity

`GeoDaWeight_GetDensity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetDensity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetDensity`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetDensity`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetDensity`) = c("SWIGFunction", class('GeoDaWeight_GetDensity'))

# Start of GeoDaWeight_GetMinNumNbrs

`GeoDaWeight_GetMinNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMinNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMinNumNbrs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetMinNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMinNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMinNumNbrs'))

# Start of GeoDaWeight_GetMaxNumNbrs

`GeoDaWeight_GetMaxNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMaxNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMaxNumNbrs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetMaxNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMaxNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMaxNumNbrs'))

# Start of GeoDaWeight_GetMeanNumNbrs

`GeoDaWeight_GetMeanNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMeanNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMeanNumNbrs`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetMeanNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMeanNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMeanNumNbrs'))

# Start of GeoDaWeight_GetMedianNumNbrs

`GeoDaWeight_GetMedianNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMedianNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMedianNumNbrs`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetMedianNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMedianNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMedianNumNbrs'))

# Start of GeoDaWeight_GetNumObs

`GeoDaWeight_GetNumObs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetNumObs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetNumObs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetNumObs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetNumObs`) = c("SWIGFunction", class('GeoDaWeight_GetNumObs'))

# Start of GeoDaWeight_IsInternalUse

`GeoDaWeight_IsInternalUse` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_IsInternalUse', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_IsInternalUse`, 'returnType') = 'logical'
attr(`GeoDaWeight_IsInternalUse`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_IsInternalUse`) = c("SWIGFunction", class('GeoDaWeight_IsInternalUse'))

# Start of GeoDaWeight_Equal

`GeoDaWeight_Equal` = function(self, gw, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(gw, "ExternalReference")) gw = slot(gw,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_Equal', self, gw, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_Equal`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDaWeight_Equal`, "inputTypes") = c('_p_GeoDaWeight', '_p_GeoDaWeight')
class(`GeoDaWeight_Equal`) = c("SWIGFunction", class('GeoDaWeight_Equal'))

# Start of GeoDaWeight_GetTitle

`GeoDaWeight_GetTitle` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetTitle', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetTitle`, 'returnType') = 'character'
attr(`GeoDaWeight_GetTitle`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetTitle`) = c("SWIGFunction", class('GeoDaWeight_GetTitle'))

# Start of GeoDaWeight_GetIDName

`GeoDaWeight_GetIDName` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetIDName', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetIDName`, 'returnType') = 'character'
attr(`GeoDaWeight_GetIDName`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetIDName`) = c("SWIGFunction", class('GeoDaWeight_GetIDName'))

# Start of GeoDaWeight_gal_type_get

`GeoDaWeight_gal_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaWeight_gal_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_gal_type_get`, 'returnType') = 'character'
class(`GeoDaWeight_gal_type_get`) = c("SWIGFunction", class('GeoDaWeight_gal_type_get'))

# Start of GeoDaWeight_gwt_type_get

`GeoDaWeight_gwt_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaWeight_gwt_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_gwt_type_get`, 'returnType') = 'character'
class(`GeoDaWeight_gwt_type_get`) = c("SWIGFunction", class('GeoDaWeight_gwt_type_get'))

# Start of GeoDaWeight_weight_type_set

`GeoDaWeight_weight_type_set` = function(self, s_weight_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_weight_type = enumToInteger(s_weight_type, "_GeoDaWeight__WeightType"); 
  
  if(length(s_weight_type) > 1) {
    warning("using only the first element of s_weight_type");
  };
  
  ;.Call('R_swig_GeoDaWeight_weight_type_set', self, s_weight_type, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_weight_type_set`, 'returnType') = 'void'
attr(`GeoDaWeight_weight_type_set`, "inputTypes") = c('_p_GeoDaWeight', 'character')
class(`GeoDaWeight_weight_type_set`) = c("SWIGFunction", class('GeoDaWeight_weight_type_set'))

# Start of GeoDaWeight_weight_type_get

`GeoDaWeight_weight_type_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_weight_type_get', self, as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_weight_type_get`, 'returnType') = 'character'
attr(`GeoDaWeight_weight_type_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_weight_type_get`) = c("SWIGFunction", class('GeoDaWeight_weight_type_get'))

# Start of GeoDaWeight_wflnm_set

`GeoDaWeight_wflnm_set` = function(self, s_wflnm)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_wflnm = as(s_wflnm, "character"); 
  ;.Call('R_swig_GeoDaWeight_wflnm_set', self, s_wflnm, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_wflnm_set`, 'returnType') = 'void'
attr(`GeoDaWeight_wflnm_set`, "inputTypes") = c('_p_GeoDaWeight', 'character')
class(`GeoDaWeight_wflnm_set`) = c("SWIGFunction", class('GeoDaWeight_wflnm_set'))

# Start of GeoDaWeight_wflnm_get

`GeoDaWeight_wflnm_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_wflnm_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_wflnm_get`, 'returnType') = 'character'
attr(`GeoDaWeight_wflnm_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_wflnm_get`) = c("SWIGFunction", class('GeoDaWeight_wflnm_get'))

# Start of GeoDaWeight_id_field_set

`GeoDaWeight_id_field_set` = function(self, s_id_field)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_id_field = as(s_id_field, "character"); 
  ;.Call('R_swig_GeoDaWeight_id_field_set', self, s_id_field, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_id_field_set`, 'returnType') = 'void'
attr(`GeoDaWeight_id_field_set`, "inputTypes") = c('_p_GeoDaWeight', 'character')
class(`GeoDaWeight_id_field_set`) = c("SWIGFunction", class('GeoDaWeight_id_field_set'))

# Start of GeoDaWeight_id_field_get

`GeoDaWeight_id_field_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_id_field_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_id_field_get`, 'returnType') = 'character'
attr(`GeoDaWeight_id_field_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_id_field_get`) = c("SWIGFunction", class('GeoDaWeight_id_field_get'))

# Start of GeoDaWeight_title_set

`GeoDaWeight_title_set` = function(self, s_title)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_title = as(s_title, "character"); 
  ;.Call('R_swig_GeoDaWeight_title_set', self, s_title, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_title_set`, 'returnType') = 'void'
attr(`GeoDaWeight_title_set`, "inputTypes") = c('_p_GeoDaWeight', 'character')
class(`GeoDaWeight_title_set`) = c("SWIGFunction", class('GeoDaWeight_title_set'))

# Start of GeoDaWeight_title_get

`GeoDaWeight_title_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_title_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_title_get`, 'returnType') = 'character'
attr(`GeoDaWeight_title_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_title_get`) = c("SWIGFunction", class('GeoDaWeight_title_get'))

# Start of GeoDaWeight_symmetry_checked_set

`GeoDaWeight_symmetry_checked_set` = function(self, s_symmetry_checked)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_symmetry_checked = as.logical(s_symmetry_checked);
  ;.Call('R_swig_GeoDaWeight_symmetry_checked_set', self, s_symmetry_checked, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_symmetry_checked_set`, 'returnType') = 'void'
attr(`GeoDaWeight_symmetry_checked_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_symmetry_checked_set`) = c("SWIGFunction", class('GeoDaWeight_symmetry_checked_set'))

# Start of GeoDaWeight_symmetry_checked_get

`GeoDaWeight_symmetry_checked_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_symmetry_checked_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_symmetry_checked_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_symmetry_checked_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_symmetry_checked_get`) = c("SWIGFunction", class('GeoDaWeight_symmetry_checked_get'))

# Start of GeoDaWeight_is_symmetric_set

`GeoDaWeight_is_symmetric_set` = function(self, s_is_symmetric)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_is_symmetric = as.logical(s_is_symmetric);
  ;.Call('R_swig_GeoDaWeight_is_symmetric_set', self, s_is_symmetric, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_symmetric_set`, 'returnType') = 'void'
attr(`GeoDaWeight_is_symmetric_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_is_symmetric_set`) = c("SWIGFunction", class('GeoDaWeight_is_symmetric_set'))

# Start of GeoDaWeight_is_symmetric_get

`GeoDaWeight_is_symmetric_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_is_symmetric_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_symmetric_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_is_symmetric_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_is_symmetric_get`) = c("SWIGFunction", class('GeoDaWeight_is_symmetric_get'))

# Start of GeoDaWeight_num_obs_set

`GeoDaWeight_num_obs_set` = function(self, s_num_obs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_num_obs = as.integer(s_num_obs);
  
  if(length(s_num_obs) > 1) {
    warning("using only the first element of s_num_obs");
  };
  
  ;.Call('R_swig_GeoDaWeight_num_obs_set', self, s_num_obs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_num_obs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_num_obs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_num_obs_set`) = c("SWIGFunction", class('GeoDaWeight_num_obs_set'))

# Start of GeoDaWeight_num_obs_get

`GeoDaWeight_num_obs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_num_obs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_num_obs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_num_obs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_num_obs_get`) = c("SWIGFunction", class('GeoDaWeight_num_obs_get'))

# Start of GeoDaWeight_sparsity_set

`GeoDaWeight_sparsity_set` = function(self, s_sparsity)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_sparsity_set', self, s_sparsity, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_sparsity_set`, 'returnType') = 'void'
attr(`GeoDaWeight_sparsity_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_sparsity_set`) = c("SWIGFunction", class('GeoDaWeight_sparsity_set'))

# Start of GeoDaWeight_sparsity_get

`GeoDaWeight_sparsity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_sparsity_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_sparsity_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_sparsity_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_sparsity_get`) = c("SWIGFunction", class('GeoDaWeight_sparsity_get'))

# Start of GeoDaWeight_density_set

`GeoDaWeight_density_set` = function(self, s_density)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_density_set', self, s_density, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_density_set`, 'returnType') = 'void'
attr(`GeoDaWeight_density_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_density_set`) = c("SWIGFunction", class('GeoDaWeight_density_set'))

# Start of GeoDaWeight_density_get

`GeoDaWeight_density_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_density_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_density_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_density_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_density_get`) = c("SWIGFunction", class('GeoDaWeight_density_get'))

# Start of GeoDaWeight_min_nbrs_set

`GeoDaWeight_min_nbrs_set` = function(self, s_min_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_min_nbrs = as.integer(s_min_nbrs);
  
  if(length(s_min_nbrs) > 1) {
    warning("using only the first element of s_min_nbrs");
  };
  
  ;.Call('R_swig_GeoDaWeight_min_nbrs_set', self, s_min_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_min_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_min_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_min_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_min_nbrs_set'))

# Start of GeoDaWeight_min_nbrs_get

`GeoDaWeight_min_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_min_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_min_nbrs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_min_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_min_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_min_nbrs_get'))

# Start of GeoDaWeight_max_nbrs_set

`GeoDaWeight_max_nbrs_set` = function(self, s_max_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_max_nbrs = as.integer(s_max_nbrs);
  
  if(length(s_max_nbrs) > 1) {
    warning("using only the first element of s_max_nbrs");
  };
  
  ;.Call('R_swig_GeoDaWeight_max_nbrs_set', self, s_max_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_max_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_max_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_max_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_max_nbrs_set'))

# Start of GeoDaWeight_max_nbrs_get

`GeoDaWeight_max_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_max_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_max_nbrs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_max_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_max_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_max_nbrs_get'))

# Start of GeoDaWeight_mean_nbrs_set

`GeoDaWeight_mean_nbrs_set` = function(self, s_mean_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_mean_nbrs_set', self, s_mean_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_mean_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_mean_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_mean_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_mean_nbrs_set'))

# Start of GeoDaWeight_mean_nbrs_get

`GeoDaWeight_mean_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_mean_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_mean_nbrs_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_mean_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_mean_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_mean_nbrs_get'))

# Start of GeoDaWeight_median_nbrs_set

`GeoDaWeight_median_nbrs_set` = function(self, s_median_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_median_nbrs_set', self, s_median_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_median_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_median_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_median_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_median_nbrs_set'))

# Start of GeoDaWeight_median_nbrs_get

`GeoDaWeight_median_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_median_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_median_nbrs_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_median_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_median_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_median_nbrs_get'))

# Start of GeoDaWeight_is_internal_use_set

`GeoDaWeight_is_internal_use_set` = function(self, s_is_internal_use)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_is_internal_use = as.logical(s_is_internal_use);
  ;.Call('R_swig_GeoDaWeight_is_internal_use_set', self, s_is_internal_use, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_internal_use_set`, 'returnType') = 'void'
attr(`GeoDaWeight_is_internal_use_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_is_internal_use_set`) = c("SWIGFunction", class('GeoDaWeight_is_internal_use_set'))

# Start of GeoDaWeight_is_internal_use_get

`GeoDaWeight_is_internal_use_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_is_internal_use_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_internal_use_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_is_internal_use_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_is_internal_use_get`) = c("SWIGFunction", class('GeoDaWeight_is_internal_use_get'))

# Start of GeoDaWeight_uid_set

`GeoDaWeight_uid_set` = function(self, s_uid)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_uid = as(s_uid, "character"); 
  ;.Call('R_swig_GeoDaWeight_uid_set', self, s_uid, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_uid_set`, 'returnType') = 'void'
attr(`GeoDaWeight_uid_set`, "inputTypes") = c('_p_GeoDaWeight', 'character')
class(`GeoDaWeight_uid_set`) = c("SWIGFunction", class('GeoDaWeight_uid_set'))

# Start of GeoDaWeight_uid_get

`GeoDaWeight_uid_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_uid_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_uid_get`, 'returnType') = 'character'
attr(`GeoDaWeight_uid_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_uid_get`) = c("SWIGFunction", class('GeoDaWeight_uid_get'))

# Start of accessor method for GeoDaWeight
setMethod('$', '_p_GeoDaWeight', function(x, name)

{
  accessorFuns = list('CheckNeighbor' = GeoDaWeight_CheckNeighbor, 'GetNeighbors' = GeoDaWeight_GetNeighbors, 'GetNeighborWeights' = GeoDaWeight_GetNeighborWeights, 'Update' = GeoDaWeight_Update, 'HasIsolates' = GeoDaWeight_HasIsolates, 'GetNbrStats' = GeoDaWeight_GetNbrStats, 'GetNbrSize' = GeoDaWeight_GetNbrSize, 'SpatialLag' = GeoDaWeight_SpatialLag, 'Save' = GeoDaWeight_Save, 'GetSparsity' = GeoDaWeight_GetSparsity, 'GetDensity' = GeoDaWeight_GetDensity, 'GetMinNumNbrs' = GeoDaWeight_GetMinNumNbrs, 'GetMaxNumNbrs' = GeoDaWeight_GetMaxNumNbrs, 'GetMeanNumNbrs' = GeoDaWeight_GetMeanNumNbrs, 'GetMedianNumNbrs' = GeoDaWeight_GetMedianNumNbrs, 'GetNumObs' = GeoDaWeight_GetNumObs, 'IsInternalUse' = GeoDaWeight_IsInternalUse, 'Equal' = GeoDaWeight_Equal, 'GetTitle' = GeoDaWeight_GetTitle, 'GetIDName' = GeoDaWeight_GetIDName, 'weight_type' = GeoDaWeight_weight_type_get, 'wflnm' = GeoDaWeight_wflnm_get, 'id_field' = GeoDaWeight_id_field_get, 'title' = GeoDaWeight_title_get, 'symmetry_checked' = GeoDaWeight_symmetry_checked_get, 'is_symmetric' = GeoDaWeight_is_symmetric_get, 'num_obs' = GeoDaWeight_num_obs_get, 'sparsity' = GeoDaWeight_sparsity_get, 'density' = GeoDaWeight_density_get, 'min_nbrs' = GeoDaWeight_min_nbrs_get, 'max_nbrs' = GeoDaWeight_max_nbrs_get, 'mean_nbrs' = GeoDaWeight_mean_nbrs_get, 'median_nbrs' = GeoDaWeight_median_nbrs_get, 'is_internal_use' = GeoDaWeight_is_internal_use_get, 'uid' = GeoDaWeight_uid_get);
  vaccessors = c('weight_type', 'wflnm', 'id_field', 'title', 'symmetry_checked', 'is_symmetric', 'num_obs', 'sparsity', 'density', 'min_nbrs', 'max_nbrs', 'mean_nbrs', 'median_nbrs', 'is_internal_use', 'uid');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaWeight
# Start of accessor method for GeoDaWeight
setMethod('$<-', '_p_GeoDaWeight', function(x, name, value)

{
  accessorFuns = list('weight_type' = GeoDaWeight_weight_type_set, 'wflnm' = GeoDaWeight_wflnm_set, 'id_field' = GeoDaWeight_id_field_set, 'title' = GeoDaWeight_title_set, 'symmetry_checked' = GeoDaWeight_symmetry_checked_set, 'is_symmetric' = GeoDaWeight_is_symmetric_set, 'num_obs' = GeoDaWeight_num_obs_set, 'sparsity' = GeoDaWeight_sparsity_set, 'density' = GeoDaWeight_density_set, 'min_nbrs' = GeoDaWeight_min_nbrs_set, 'max_nbrs' = GeoDaWeight_max_nbrs_set, 'mean_nbrs' = GeoDaWeight_mean_nbrs_set, 'median_nbrs' = GeoDaWeight_median_nbrs_set, 'is_internal_use' = GeoDaWeight_is_internal_use_set, 'uid' = GeoDaWeight_uid_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaWeight', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('weight_type' = GeoDaWeight_weight_type_set, 'wflnm' = GeoDaWeight_wflnm_set, 'id_field' = GeoDaWeight_id_field_set, 'title' = GeoDaWeight_title_set, 'symmetry_checked' = GeoDaWeight_symmetry_checked_set, 'is_symmetric' = GeoDaWeight_is_symmetric_set, 'num_obs' = GeoDaWeight_num_obs_set, 'sparsity' = GeoDaWeight_sparsity_set, 'density' = GeoDaWeight_density_set, 'min_nbrs' = GeoDaWeight_min_nbrs_set, 'max_nbrs' = GeoDaWeight_max_nbrs_set, 'mean_nbrs' = GeoDaWeight_mean_nbrs_set, 'median_nbrs' = GeoDaWeight_median_nbrs_set, 'is_internal_use' = GeoDaWeight_is_internal_use_set, 'uid' = GeoDaWeight_uid_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaWeight
setMethod('delete', '_p_GeoDaWeight', function(obj) {delete_GeoDaWeight(obj)})
# Start of delete_LISA

`delete_LISA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_LISA', self, PACKAGE='rgeoda');
  
}

attr(`delete_LISA`, 'returnType') = 'void'
attr(`delete_LISA`, "inputTypes") = c('_p_LISA')
class(`delete_LISA`) = c("SWIGFunction", class('delete_LISA'))

# Start of LISA_ComputeLoalSA

`LISA_ComputeLoalSA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_ComputeLoalSA', self, PACKAGE='rgeoda');
  
}

attr(`LISA_ComputeLoalSA`, 'returnType') = 'void'
attr(`LISA_ComputeLoalSA`, "inputTypes") = c('_p_LISA')
class(`LISA_ComputeLoalSA`) = c("SWIGFunction", class('LISA_ComputeLoalSA'))

# Start of LISA_CalcPseudoP

`LISA_CalcPseudoP` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_CalcPseudoP', self, PACKAGE='rgeoda');
  
}

attr(`LISA_CalcPseudoP`, 'returnType') = 'void'
attr(`LISA_CalcPseudoP`, "inputTypes") = c('_p_LISA')
class(`LISA_CalcPseudoP`) = c("SWIGFunction", class('LISA_CalcPseudoP'))

# Start of LISA_CalcPseudoP_threaded

`LISA_CalcPseudoP_threaded` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_CalcPseudoP_threaded', self, PACKAGE='rgeoda');
  
}

attr(`LISA_CalcPseudoP_threaded`, 'returnType') = 'void'
attr(`LISA_CalcPseudoP_threaded`, "inputTypes") = c('_p_LISA')
class(`LISA_CalcPseudoP_threaded`) = c("SWIGFunction", class('LISA_CalcPseudoP_threaded'))

# Start of LISA_CalcPseudoP_range

`LISA_CalcPseudoP_range` = function(self, obs_start, obs_end, seed_start)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_start = as.integer(obs_start);
  
  if(length(obs_start) > 1) {
    warning("using only the first element of obs_start");
  };
  
  obs_end = as.integer(obs_end);
  
  if(length(obs_end) > 1) {
    warning("using only the first element of obs_end");
  };
  
  if (inherits(seed_start, "ExternalReference")) seed_start = slot(seed_start,"ref") 
  ;.Call('R_swig_LISA_CalcPseudoP_range', self, obs_start, obs_end, seed_start, PACKAGE='rgeoda');
  
}

attr(`LISA_CalcPseudoP_range`, 'returnType') = 'void'
attr(`LISA_CalcPseudoP_range`, "inputTypes") = c('_p_LISA', 'integer', 'integer', '_p_uint64_t')
class(`LISA_CalcPseudoP_range`) = c("SWIGFunction", class('LISA_CalcPseudoP_range'))

# Start of LISA_PermLocalSA

`LISA_PermLocalSA` = function(self, cnt, perm, permNeighbors, permutedSA)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  cnt = as.integer(cnt);
  
  if(length(cnt) > 1) {
    warning("using only the first element of cnt");
  };
  
  perm = as.integer(perm);
  
  if(length(perm) > 1) {
    warning("using only the first element of perm");
  };
  
  permNeighbors = as.integer(permNeighbors);
  permutedSA = as.numeric(permutedSA);
  ;.Call('R_swig_LISA_PermLocalSA', self, cnt, perm, permNeighbors, permutedSA, PACKAGE='rgeoda');
  
}

attr(`LISA_PermLocalSA`, 'returnType') = 'void'
attr(`LISA_PermLocalSA`, "inputTypes") = c('_p_LISA', 'integer', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`LISA_PermLocalSA`) = c("SWIGFunction", class('LISA_PermLocalSA'))

# Start of LISA_CountLargerSA

`LISA_CountLargerSA` = function(self, cnt, permutedSA, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  cnt = as.integer(cnt);
  
  if(length(cnt) > 1) {
    warning("using only the first element of cnt");
  };
  
  permutedSA = as.numeric(permutedSA);
  ;ans = .Call('R_swig_LISA_CountLargerSA', self, cnt, permutedSA, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_uint64_t", ref=ans);
  
  ans
  
}

attr(`LISA_CountLargerSA`, 'returnType') = '_p_uint64_t'
attr(`LISA_CountLargerSA`, "inputTypes") = c('_p_LISA', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`LISA_CountLargerSA`) = c("SWIGFunction", class('LISA_CountLargerSA'))

# Start of LISA_Run

`LISA_Run` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_Run', self, PACKAGE='rgeoda');
  
}

attr(`LISA_Run`, 'returnType') = 'void'
attr(`LISA_Run`, "inputTypes") = c('_p_LISA')
class(`LISA_Run`) = c("SWIGFunction", class('LISA_Run'))

# Start of LISA_SetSignificanceFilter

`LISA_SetSignificanceFilter` = function(self, filter_id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filter_id = as.integer(filter_id);
  
  if(length(filter_id) > 1) {
    warning("using only the first element of filter_id");
  };
  
  ;.Call('R_swig_LISA_SetSignificanceFilter', self, filter_id, PACKAGE='rgeoda');
  
}

attr(`LISA_SetSignificanceFilter`, 'returnType') = 'void'
attr(`LISA_SetSignificanceFilter`, "inputTypes") = c('_p_LISA', 'integer')
class(`LISA_SetSignificanceFilter`) = c("SWIGFunction", class('LISA_SetSignificanceFilter'))

# Start of LISA_GetSignificanceFilter

`LISA_GetSignificanceFilter` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetSignificanceFilter', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetSignificanceFilter`, 'returnType') = 'integer'
attr(`LISA_GetSignificanceFilter`, "inputTypes") = c('_p_LISA')
class(`LISA_GetSignificanceFilter`) = c("SWIGFunction", class('LISA_GetSignificanceFilter'))

# Start of LISA_GetSignificanceCutoff

`LISA_GetSignificanceCutoff` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetSignificanceCutoff', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetSignificanceCutoff`, 'returnType') = 'numeric'
attr(`LISA_GetSignificanceCutoff`, "inputTypes") = c('_p_LISA')
class(`LISA_GetSignificanceCutoff`) = c("SWIGFunction", class('LISA_GetSignificanceCutoff'))

# Start of LISA_SetSignificanceCutoff

`LISA_SetSignificanceCutoff` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_LISA_SetSignificanceCutoff', self, val, PACKAGE='rgeoda');
  
}

attr(`LISA_SetSignificanceCutoff`, 'returnType') = 'void'
attr(`LISA_SetSignificanceCutoff`, "inputTypes") = c('_p_LISA', 'numeric')
class(`LISA_SetSignificanceCutoff`) = c("SWIGFunction", class('LISA_SetSignificanceCutoff'))

# Start of LISA_GetUserCutoff

`LISA_GetUserCutoff` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetUserCutoff', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetUserCutoff`, 'returnType') = 'numeric'
attr(`LISA_GetUserCutoff`, "inputTypes") = c('_p_LISA')
class(`LISA_GetUserCutoff`) = c("SWIGFunction", class('LISA_GetUserCutoff'))

# Start of LISA_SetUserCutoff

`LISA_SetUserCutoff` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_LISA_SetUserCutoff', self, val, PACKAGE='rgeoda');
  
}

attr(`LISA_SetUserCutoff`, 'returnType') = 'void'
attr(`LISA_SetUserCutoff`, "inputTypes") = c('_p_LISA', 'numeric')
class(`LISA_SetUserCutoff`) = c("SWIGFunction", class('LISA_SetUserCutoff'))

# Start of LISA_GetBO

`LISA_GetBO` = function(self, current_p, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_LISA_GetBO', self, current_p, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetBO`, 'returnType') = 'numeric'
attr(`LISA_GetBO`, "inputTypes") = c('_p_LISA', 'numeric')
class(`LISA_GetBO`) = c("SWIGFunction", class('LISA_GetBO'))

# Start of LISA_GetFDR

`LISA_GetFDR` = function(self, current_p, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_LISA_GetFDR', self, current_p, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetFDR`, 'returnType') = 'numeric'
attr(`LISA_GetFDR`, "inputTypes") = c('_p_LISA', 'numeric')
class(`LISA_GetFDR`) = c("SWIGFunction", class('LISA_GetFDR'))

# Start of LISA_GetNumPermutations

`LISA_GetNumPermutations` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetNumPermutations', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetNumPermutations`, 'returnType') = 'integer'
attr(`LISA_GetNumPermutations`, "inputTypes") = c('_p_LISA')
class(`LISA_GetNumPermutations`) = c("SWIGFunction", class('LISA_GetNumPermutations'))

# Start of LISA_SetNumPermutations

`LISA_SetNumPermutations` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  val = as.integer(val);
  
  if(length(val) > 1) {
    warning("using only the first element of val");
  };
  
  ;.Call('R_swig_LISA_SetNumPermutations', self, val, PACKAGE='rgeoda');
  
}

attr(`LISA_SetNumPermutations`, 'returnType') = 'void'
attr(`LISA_SetNumPermutations`, "inputTypes") = c('_p_LISA', 'integer')
class(`LISA_SetNumPermutations`) = c("SWIGFunction", class('LISA_SetNumPermutations'))

# Start of LISA_GetLastUsedSeed

`LISA_GetLastUsedSeed` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LISA_GetLastUsedSeed', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_uint64_t", ref=ans);
  
  ans
  
}

attr(`LISA_GetLastUsedSeed`, 'returnType') = '_p_uint64_t'
attr(`LISA_GetLastUsedSeed`, "inputTypes") = c('_p_LISA')
class(`LISA_GetLastUsedSeed`) = c("SWIGFunction", class('LISA_GetLastUsedSeed'))

# Start of LISA_SetLastUsedSeed

`LISA_SetLastUsedSeed` = function(self, seed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(seed, "ExternalReference")) seed = slot(seed,"ref") 
  ;.Call('R_swig_LISA_SetLastUsedSeed', self, seed, PACKAGE='rgeoda');
  
}

attr(`LISA_SetLastUsedSeed`, 'returnType') = 'void'
attr(`LISA_SetLastUsedSeed`, "inputTypes") = c('_p_LISA', '_p_uint64_t')
class(`LISA_SetLastUsedSeed`) = c("SWIGFunction", class('LISA_SetLastUsedSeed'))

# Start of LISA_IsReuseLastSeed

`LISA_IsReuseLastSeed` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_IsReuseLastSeed', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_IsReuseLastSeed`, 'returnType') = 'logical'
attr(`LISA_IsReuseLastSeed`, "inputTypes") = c('_p_LISA')
class(`LISA_IsReuseLastSeed`) = c("SWIGFunction", class('LISA_IsReuseLastSeed'))

# Start of LISA_SetReuseLastSeed

`LISA_SetReuseLastSeed` = function(self, reuse)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  reuse = as.logical(reuse);
  ;.Call('R_swig_LISA_SetReuseLastSeed', self, reuse, PACKAGE='rgeoda');
  
}

attr(`LISA_SetReuseLastSeed`, 'returnType') = 'void'
attr(`LISA_SetReuseLastSeed`, "inputTypes") = c('_p_LISA', 'logical')
class(`LISA_SetReuseLastSeed`) = c("SWIGFunction", class('LISA_SetReuseLastSeed'))

# Start of LISA_GetHasIsolates

`LISA_GetHasIsolates` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetHasIsolates', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetHasIsolates`, 'returnType') = 'logical'
attr(`LISA_GetHasIsolates`, "inputTypes") = c('_p_LISA')
class(`LISA_GetHasIsolates`) = c("SWIGFunction", class('LISA_GetHasIsolates'))

# Start of LISA_GetHasUndefined

`LISA_GetHasUndefined` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetHasUndefined', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetHasUndefined`, 'returnType') = 'logical'
attr(`LISA_GetHasUndefined`, "inputTypes") = c('_p_LISA')
class(`LISA_GetHasUndefined`) = c("SWIGFunction", class('LISA_GetHasUndefined'))

# Start of LISA_GetDefaultCategories

`LISA_GetDefaultCategories` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetDefaultCategories', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetDefaultCategories`, 'returnType') = 'character'
attr(`LISA_GetDefaultCategories`, "inputTypes") = c('_p_LISA')
class(`LISA_GetDefaultCategories`) = c("SWIGFunction", class('LISA_GetDefaultCategories'))

# Start of LISA_GetDefaultCutoffs

`LISA_GetDefaultCutoffs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetDefaultCutoffs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetDefaultCutoffs`, 'returnType') = 'numeric'
attr(`LISA_GetDefaultCutoffs`, "inputTypes") = c('_p_LISA')
class(`LISA_GetDefaultCutoffs`) = c("SWIGFunction", class('LISA_GetDefaultCutoffs'))

# Start of LISA_GetLocalSignificanceValues

`LISA_GetLocalSignificanceValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetLocalSignificanceValues', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetLocalSignificanceValues`, 'returnType') = 'numeric'
attr(`LISA_GetLocalSignificanceValues`, "inputTypes") = c('_p_LISA')
class(`LISA_GetLocalSignificanceValues`) = c("SWIGFunction", class('LISA_GetLocalSignificanceValues'))

# Start of LISA_GetClusterIndicators

`LISA_GetClusterIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetClusterIndicators', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetClusterIndicators`, 'returnType') = 'integer'
attr(`LISA_GetClusterIndicators`, "inputTypes") = c('_p_LISA')
class(`LISA_GetClusterIndicators`) = c("SWIGFunction", class('LISA_GetClusterIndicators'))

# Start of LISA_GetSigCatIndicators

`LISA_GetSigCatIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetSigCatIndicators', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetSigCatIndicators`, 'returnType') = 'integer'
attr(`LISA_GetSigCatIndicators`, "inputTypes") = c('_p_LISA')
class(`LISA_GetSigCatIndicators`) = c("SWIGFunction", class('LISA_GetSigCatIndicators'))

# Start of LISA_GetNumNeighbors

`LISA_GetNumNeighbors` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetNumNeighbors', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetNumNeighbors`, 'returnType') = 'integer'
attr(`LISA_GetNumNeighbors`, "inputTypes") = c('_p_LISA')
class(`LISA_GetNumNeighbors`) = c("SWIGFunction", class('LISA_GetNumNeighbors'))

# Start of LISA_GetSpatialLagValues

`LISA_GetSpatialLagValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetSpatialLagValues', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetSpatialLagValues`, 'returnType') = 'numeric'
attr(`LISA_GetSpatialLagValues`, "inputTypes") = c('_p_LISA')
class(`LISA_GetSpatialLagValues`) = c("SWIGFunction", class('LISA_GetSpatialLagValues'))

# Start of LISA_GetLISAValues

`LISA_GetLISAValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetLISAValues', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetLISAValues`, 'returnType') = 'numeric'
attr(`LISA_GetLISAValues`, "inputTypes") = c('_p_LISA')
class(`LISA_GetLISAValues`) = c("SWIGFunction", class('LISA_GetLISAValues'))

# Start of LISA_IsRowStandardize

`LISA_IsRowStandardize` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_IsRowStandardize', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_IsRowStandardize`, 'returnType') = 'logical'
attr(`LISA_IsRowStandardize`, "inputTypes") = c('_p_LISA')
class(`LISA_IsRowStandardize`) = c("SWIGFunction", class('LISA_IsRowStandardize'))

# Start of LISA_SetRowStandardize

`LISA_SetRowStandardize` = function(self, rowStandardize)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  rowStandardize = as.logical(rowStandardize);
  ;.Call('R_swig_LISA_SetRowStandardize', self, rowStandardize, PACKAGE='rgeoda');
  
}

attr(`LISA_SetRowStandardize`, 'returnType') = 'void'
attr(`LISA_SetRowStandardize`, "inputTypes") = c('_p_LISA', 'logical')
class(`LISA_SetRowStandardize`) = c("SWIGFunction", class('LISA_SetRowStandardize'))

# Start of LISA_GetNumThreads

`LISA_GetNumThreads` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetNumThreads', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetNumThreads`, 'returnType') = 'integer'
attr(`LISA_GetNumThreads`, "inputTypes") = c('_p_LISA')
class(`LISA_GetNumThreads`) = c("SWIGFunction", class('LISA_GetNumThreads'))

# Start of LISA_SetNumThreads

`LISA_SetNumThreads` = function(self, n_threads)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n_threads = as.integer(n_threads);
  
  if(length(n_threads) > 1) {
    warning("using only the first element of n_threads");
  };
  
  ;.Call('R_swig_LISA_SetNumThreads', self, n_threads, PACKAGE='rgeoda');
  
}

attr(`LISA_SetNumThreads`, 'returnType') = 'void'
attr(`LISA_SetNumThreads`, "inputTypes") = c('_p_LISA', 'integer')
class(`LISA_SetNumThreads`) = c("SWIGFunction", class('LISA_SetNumThreads'))

# Start of LISA_GetLabels

`LISA_GetLabels` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetLabels', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetLabels`, 'returnType') = 'character'
attr(`LISA_GetLabels`, "inputTypes") = c('_p_LISA')
class(`LISA_GetLabels`) = c("SWIGFunction", class('LISA_GetLabels'))

# Start of LISA_GetColors

`LISA_GetColors` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LISA_GetColors', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`LISA_GetColors`, 'returnType') = 'character'
attr(`LISA_GetColors`, "inputTypes") = c('_p_LISA')
class(`LISA_GetColors`) = c("SWIGFunction", class('LISA_GetColors'))

# Start of accessor method for LISA
setMethod('$', '_p_LISA', function(x, name)

{
  accessorFuns = list('ComputeLoalSA' = LISA_ComputeLoalSA, 'CalcPseudoP' = LISA_CalcPseudoP, 'CalcPseudoP_threaded' = LISA_CalcPseudoP_threaded, 'CalcPseudoP_range' = LISA_CalcPseudoP_range, 'PermLocalSA' = LISA_PermLocalSA, 'CountLargerSA' = LISA_CountLargerSA, 'Run' = LISA_Run, 'SetSignificanceFilter' = LISA_SetSignificanceFilter, 'GetSignificanceFilter' = LISA_GetSignificanceFilter, 'GetSignificanceCutoff' = LISA_GetSignificanceCutoff, 'SetSignificanceCutoff' = LISA_SetSignificanceCutoff, 'GetUserCutoff' = LISA_GetUserCutoff, 'SetUserCutoff' = LISA_SetUserCutoff, 'GetBO' = LISA_GetBO, 'GetFDR' = LISA_GetFDR, 'GetNumPermutations' = LISA_GetNumPermutations, 'SetNumPermutations' = LISA_SetNumPermutations, 'GetLastUsedSeed' = LISA_GetLastUsedSeed, 'SetLastUsedSeed' = LISA_SetLastUsedSeed, 'IsReuseLastSeed' = LISA_IsReuseLastSeed, 'SetReuseLastSeed' = LISA_SetReuseLastSeed, 'GetHasIsolates' = LISA_GetHasIsolates, 'GetHasUndefined' = LISA_GetHasUndefined, 'GetDefaultCategories' = LISA_GetDefaultCategories, 'GetDefaultCutoffs' = LISA_GetDefaultCutoffs, 'GetLocalSignificanceValues' = LISA_GetLocalSignificanceValues, 'GetClusterIndicators' = LISA_GetClusterIndicators, 'GetSigCatIndicators' = LISA_GetSigCatIndicators, 'GetNumNeighbors' = LISA_GetNumNeighbors, 'GetSpatialLagValues' = LISA_GetSpatialLagValues, 'GetLISAValues' = LISA_GetLISAValues, 'IsRowStandardize' = LISA_IsRowStandardize, 'SetRowStandardize' = LISA_SetRowStandardize, 'GetNumThreads' = LISA_GetNumThreads, 'SetNumThreads' = LISA_SetNumThreads, 'GetLabels' = LISA_GetLabels, 'GetColors' = LISA_GetColors);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for LISA
setMethod('delete', '_p_LISA', function(obj) {delete_LISA(obj)})
# Start of delete_AbstractGeoDa

`delete_AbstractGeoDa` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_AbstractGeoDa', self, PACKAGE='rgeoda');
  
}

attr(`delete_AbstractGeoDa`, 'returnType') = 'void'
attr(`delete_AbstractGeoDa`, "inputTypes") = c('_p_AbstractGeoDa')
class(`delete_AbstractGeoDa`) = c("SWIGFunction", class('delete_AbstractGeoDa'))

# Start of AbstractGeoDa_GetNumObs

`AbstractGeoDa_GetNumObs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractGeoDa_GetNumObs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractGeoDa_GetNumObs`, 'returnType') = 'integer'
attr(`AbstractGeoDa_GetNumObs`, "inputTypes") = c('_p_AbstractGeoDa')
class(`AbstractGeoDa_GetNumObs`) = c("SWIGFunction", class('AbstractGeoDa_GetNumObs'))

# Start of AbstractGeoDa_GetCentroids

`AbstractGeoDa_GetCentroids` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractGeoDa_GetCentroids', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_gda__PointContents_p_std__allocatorT_gda__PointContents_p_t_t", ref=ans);
  
  ans
  
}

attr(`AbstractGeoDa_GetCentroids`, 'returnType') = '_p_std__vectorT_gda__PointContents_p_std__allocatorT_gda__PointContents_p_t_t'
attr(`AbstractGeoDa_GetCentroids`, "inputTypes") = c('_p_AbstractGeoDa')
class(`AbstractGeoDa_GetCentroids`) = c("SWIGFunction", class('AbstractGeoDa_GetCentroids'))

# Start of AbstractGeoDa_GetMapType

`AbstractGeoDa_GetMapType` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractGeoDa_GetMapType', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractGeoDa_GetMapType`, 'returnType') = 'integer'
attr(`AbstractGeoDa_GetMapType`, "inputTypes") = c('_p_AbstractGeoDa')
class(`AbstractGeoDa_GetMapType`) = c("SWIGFunction", class('AbstractGeoDa_GetMapType'))

# Start of AbstractGeoDa_GetMainMap

`AbstractGeoDa_GetMainMap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractGeoDa_GetMainMap', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_gda__MainMap", ref=ans);
  
  ans
  
}

attr(`AbstractGeoDa_GetMainMap`, 'returnType') = '_p_gda__MainMap'
attr(`AbstractGeoDa_GetMainMap`, "inputTypes") = c('_p_AbstractGeoDa')
class(`AbstractGeoDa_GetMainMap`) = c("SWIGFunction", class('AbstractGeoDa_GetMainMap'))

# Start of accessor method for AbstractGeoDa
setMethod('$', '_p_AbstractGeoDa', function(x, name)

{
  accessorFuns = list('GetNumObs' = AbstractGeoDa_GetNumObs, 'GetCentroids' = AbstractGeoDa_GetCentroids, 'GetMapType' = AbstractGeoDa_GetMapType, 'GetMainMap' = AbstractGeoDa_GetMainMap);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for AbstractGeoDa
setMethod('delete', '_p_AbstractGeoDa', function(obj) {delete_AbstractGeoDa(obj)})
# Start of GeoDaColumn_integer_type_get

`GeoDaColumn_integer_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaColumn_integer_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_integer_type_get`, 'returnType') = 'character'
class(`GeoDaColumn_integer_type_get`) = c("SWIGFunction", class('GeoDaColumn_integer_type_get'))

# Start of GeoDaColumn_string_type_get

`GeoDaColumn_string_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaColumn_string_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_string_type_get`, 'returnType') = 'character'
class(`GeoDaColumn_string_type_get`) = c("SWIGFunction", class('GeoDaColumn_string_type_get'))

# Start of GeoDaColumn_real_type_get

`GeoDaColumn_real_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaColumn_real_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_real_type_get`, 'returnType') = 'character'
class(`GeoDaColumn_real_type_get`) = c("SWIGFunction", class('GeoDaColumn_real_type_get'))

# Start of GeoDaColumn_name_set

`GeoDaColumn_name_set` = function(self, s_name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_name = as(s_name, "character"); 
  ;.Call('R_swig_GeoDaColumn_name_set', self, s_name, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_name_set`, 'returnType') = 'void'
attr(`GeoDaColumn_name_set`, "inputTypes") = c('_p_GeoDaColumn', 'character')
class(`GeoDaColumn_name_set`) = c("SWIGFunction", class('GeoDaColumn_name_set'))

# Start of GeoDaColumn_name_get

`GeoDaColumn_name_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaColumn_name_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_name_get`, 'returnType') = 'character'
attr(`GeoDaColumn_name_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_name_get`) = c("SWIGFunction", class('GeoDaColumn_name_get'))

# Start of GeoDaColumn_field_type_set

`GeoDaColumn_field_type_set` = function(self, s_field_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_field_type = enumToInteger(s_field_type, "_GeoDaColumn__FieldType"); 
  
  if(length(s_field_type) > 1) {
    warning("using only the first element of s_field_type");
  };
  
  ;.Call('R_swig_GeoDaColumn_field_type_set', self, s_field_type, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_type_set`, 'returnType') = 'void'
attr(`GeoDaColumn_field_type_set`, "inputTypes") = c('_p_GeoDaColumn', 'character')
class(`GeoDaColumn_field_type_set`) = c("SWIGFunction", class('GeoDaColumn_field_type_set'))

# Start of GeoDaColumn_field_type_get

`GeoDaColumn_field_type_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaColumn_field_type_get', self, as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_field_type_get`, 'returnType') = 'character'
attr(`GeoDaColumn_field_type_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_field_type_get`) = c("SWIGFunction", class('GeoDaColumn_field_type_get'))

# Start of GeoDaColumn_field_length_set

`GeoDaColumn_field_length_set` = function(self, s_field_length)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_field_length = as.integer(s_field_length);
  
  if(length(s_field_length) > 1) {
    warning("using only the first element of s_field_length");
  };
  
  ;.Call('R_swig_GeoDaColumn_field_length_set', self, s_field_length, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_length_set`, 'returnType') = 'void'
attr(`GeoDaColumn_field_length_set`, "inputTypes") = c('_p_GeoDaColumn', 'integer')
class(`GeoDaColumn_field_length_set`) = c("SWIGFunction", class('GeoDaColumn_field_length_set'))

# Start of GeoDaColumn_field_length_get

`GeoDaColumn_field_length_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaColumn_field_length_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_length_get`, 'returnType') = 'integer'
attr(`GeoDaColumn_field_length_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_field_length_get`) = c("SWIGFunction", class('GeoDaColumn_field_length_get'))

# Start of GeoDaColumn_field_decimals_set

`GeoDaColumn_field_decimals_set` = function(self, s_field_decimals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_field_decimals = as.integer(s_field_decimals);
  
  if(length(s_field_decimals) > 1) {
    warning("using only the first element of s_field_decimals");
  };
  
  ;.Call('R_swig_GeoDaColumn_field_decimals_set', self, s_field_decimals, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_decimals_set`, 'returnType') = 'void'
attr(`GeoDaColumn_field_decimals_set`, "inputTypes") = c('_p_GeoDaColumn', 'integer')
class(`GeoDaColumn_field_decimals_set`) = c("SWIGFunction", class('GeoDaColumn_field_decimals_set'))

# Start of GeoDaColumn_field_decimals_get

`GeoDaColumn_field_decimals_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaColumn_field_decimals_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_decimals_get`, 'returnType') = 'integer'
attr(`GeoDaColumn_field_decimals_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_field_decimals_get`) = c("SWIGFunction", class('GeoDaColumn_field_decimals_get'))

# Start of GeoDaColumn_undefs_set

`GeoDaColumn_undefs_set` = function(self, s_undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_undefs, "ExternalReference")) s_undefs = slot(s_undefs,"ref") 
  ;.Call('R_swig_GeoDaColumn_undefs_set', self, s_undefs, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_undefs_set`, 'returnType') = 'void'
attr(`GeoDaColumn_undefs_set`, "inputTypes") = c('_p_GeoDaColumn', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDaColumn_undefs_set`) = c("SWIGFunction", class('GeoDaColumn_undefs_set'))

# Start of GeoDaColumn_undefs_get

`GeoDaColumn_undefs_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaColumn_undefs_get', self, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_undefs_get`, 'returnType') = '_p_std__vectorT_bool_std__allocatorT_bool_t_t'
attr(`GeoDaColumn_undefs_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_undefs_get`) = c("SWIGFunction", class('GeoDaColumn_undefs_get'))

# Start of new_GeoDaColumn

`GeoDaColumn` = function(nm, ft, flen, fdec)
{
  nm = as(nm, "character"); 
  ft = enumToInteger(ft, "_GeoDaColumn__FieldType"); 
  
  if(length(ft) > 1) {
    warning("using only the first element of ft");
  };
  
  flen = as.integer(flen);
  
  if(length(flen) > 1) {
    warning("using only the first element of flen");
  };
  
  fdec = as.integer(fdec);
  
  if(length(fdec) > 1) {
    warning("using only the first element of fdec");
  };
  
  ;ans = .Call('R_swig_new_GeoDaColumn', nm, ft, flen, fdec, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaColumn)
  ans
  
}

attr(`GeoDaColumn`, 'returnType') = '_p_GeoDaColumn'
attr(`GeoDaColumn`, "inputTypes") = c('character', 'character', 'integer', 'integer')
class(`GeoDaColumn`) = c("SWIGFunction", class('GeoDaColumn'))

# Start of delete_GeoDaColumn

`delete_GeoDaColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaColumn`, 'returnType') = 'void'
attr(`delete_GeoDaColumn`, "inputTypes") = c('_p_GeoDaColumn')
class(`delete_GeoDaColumn`) = c("SWIGFunction", class('delete_GeoDaColumn'))

# Start of accessor method for GeoDaColumn
setMethod('$', '_p_GeoDaColumn', function(x, name)

{
  accessorFuns = list('name' = GeoDaColumn_name_get, 'field_type' = GeoDaColumn_field_type_get, 'field_length' = GeoDaColumn_field_length_get, 'field_decimals' = GeoDaColumn_field_decimals_get, 'undefs' = GeoDaColumn_undefs_get);
  vaccessors = c('name', 'field_type', 'field_length', 'field_decimals', 'undefs');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaColumn
# Start of accessor method for GeoDaColumn
setMethod('$<-', '_p_GeoDaColumn', function(x, name, value)

{
  accessorFuns = list('name' = GeoDaColumn_name_set, 'field_type' = GeoDaColumn_field_type_set, 'field_length' = GeoDaColumn_field_length_set, 'field_decimals' = GeoDaColumn_field_decimals_set, 'undefs' = GeoDaColumn_undefs_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('name' = GeoDaColumn_name_set, 'field_type' = GeoDaColumn_field_type_set, 'field_length' = GeoDaColumn_field_length_set, 'field_decimals' = GeoDaColumn_field_decimals_set, 'undefs' = GeoDaColumn_undefs_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaColumn
setMethod('delete', '_p_GeoDaColumn', function(obj) {delete_GeoDaColumn(obj)})
# Start of GeoDaIntColumn_data_set

`GeoDaIntColumn_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  ;.Call('R_swig_GeoDaIntColumn_data_set', self, s_data, PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_data_set`, 'returnType') = 'void'
attr(`GeoDaIntColumn_data_set`, "inputTypes") = c('_p_GeoDaIntColumn', 'integer')
class(`GeoDaIntColumn_data_set`) = c("SWIGFunction", class('GeoDaIntColumn_data_set'))

# Start of GeoDaIntColumn_data_get

`GeoDaIntColumn_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaIntColumn_data_get', self, PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_data_get`, 'returnType') = 'integer'
attr(`GeoDaIntColumn_data_get`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`GeoDaIntColumn_data_get`) = c("SWIGFunction", class('GeoDaIntColumn_data_get'))

# Start of GeoDaIntColumn_GetData

`GeoDaIntColumn_GetData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaIntColumn_GetData', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_GetData`, 'returnType') = 'integer'
attr(`GeoDaIntColumn_GetData`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`GeoDaIntColumn_GetData`) = c("SWIGFunction", class('GeoDaIntColumn_GetData'))

# Start of GeoDaIntColumn_SetData

`GeoDaIntColumn_SetData` = function(self, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  vals = as.integer(vals);
  ;.Call('R_swig_GeoDaIntColumn_SetData', self, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_SetData`, 'returnType') = 'void'
attr(`GeoDaIntColumn_SetData`, "inputTypes") = c('_p_GeoDaIntColumn', 'integer')
class(`GeoDaIntColumn_SetData`) = c("SWIGFunction", class('GeoDaIntColumn_SetData'))

# Start of new_GeoDaIntColumn

`GeoDaIntColumn` = function(nm, vals)
{
  nm = as(nm, "character"); 
  vals = as.integer(vals);
  ;ans = .Call('R_swig_new_GeoDaIntColumn', nm, vals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaIntColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaIntColumn)
  ans
  
}

attr(`GeoDaIntColumn`, 'returnType') = '_p_GeoDaIntColumn'
attr(`GeoDaIntColumn`, "inputTypes") = c('character', 'integer')
class(`GeoDaIntColumn`) = c("SWIGFunction", class('GeoDaIntColumn'))

# Start of delete_GeoDaIntColumn

`delete_GeoDaIntColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaIntColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaIntColumn`, 'returnType') = 'void'
attr(`delete_GeoDaIntColumn`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`delete_GeoDaIntColumn`) = c("SWIGFunction", class('delete_GeoDaIntColumn'))

# Start of accessor method for GeoDaIntColumn
setMethod('$', '_p_GeoDaIntColumn', function(x, name)

{
  accessorFuns = list('data' = GeoDaIntColumn_data_get, 'GetData' = GeoDaIntColumn_GetData, 'SetData' = GeoDaIntColumn_SetData);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaIntColumn
# Start of accessor method for GeoDaIntColumn
setMethod('$<-', '_p_GeoDaIntColumn', function(x, name, value)

{
  accessorFuns = list('data' = GeoDaIntColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaIntColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = GeoDaIntColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaIntColumn
setMethod('delete', '_p_GeoDaIntColumn', function(obj) {delete_GeoDaIntColumn(obj)})
# Start of GeoDaStringColumn_data_set

`GeoDaStringColumn_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_GeoDaStringColumn_data_set', self, s_data, PACKAGE='rgeoda');
  
}

attr(`GeoDaStringColumn_data_set`, 'returnType') = 'void'
attr(`GeoDaStringColumn_data_set`, "inputTypes") = c('_p_GeoDaStringColumn', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaStringColumn_data_set`) = c("SWIGFunction", class('GeoDaStringColumn_data_set'))

# Start of GeoDaStringColumn_data_get

`GeoDaStringColumn_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaStringColumn_data_get', self, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDaStringColumn_data_get`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`GeoDaStringColumn_data_get`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`GeoDaStringColumn_data_get`) = c("SWIGFunction", class('GeoDaStringColumn_data_get'))

# Start of GeoDaStringColumn_GetData

`GeoDaStringColumn_GetData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaStringColumn_GetData', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDaStringColumn_GetData`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`GeoDaStringColumn_GetData`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`GeoDaStringColumn_GetData`) = c("SWIGFunction", class('GeoDaStringColumn_GetData'))

# Start of GeoDaStringColumn_SetData

`GeoDaStringColumn_SetData` = function(self, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(vals, "ExternalReference")) vals = slot(vals,"ref") 
  ;.Call('R_swig_GeoDaStringColumn_SetData', self, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaStringColumn_SetData`, 'returnType') = 'void'
attr(`GeoDaStringColumn_SetData`, "inputTypes") = c('_p_GeoDaStringColumn', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaStringColumn_SetData`) = c("SWIGFunction", class('GeoDaStringColumn_SetData'))

# Start of new_GeoDaStringColumn

`GeoDaStringColumn` = function(nm, vals)
{
  nm = as(nm, "character"); 
  if (inherits(vals, "ExternalReference")) vals = slot(vals,"ref") 
  ;ans = .Call('R_swig_new_GeoDaStringColumn', nm, vals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaStringColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaStringColumn)
  ans
  
}

attr(`GeoDaStringColumn`, 'returnType') = '_p_GeoDaStringColumn'
attr(`GeoDaStringColumn`, "inputTypes") = c('character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaStringColumn`) = c("SWIGFunction", class('GeoDaStringColumn'))

# Start of delete_GeoDaStringColumn

`delete_GeoDaStringColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaStringColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaStringColumn`, 'returnType') = 'void'
attr(`delete_GeoDaStringColumn`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`delete_GeoDaStringColumn`) = c("SWIGFunction", class('delete_GeoDaStringColumn'))

# Start of accessor method for GeoDaStringColumn
setMethod('$', '_p_GeoDaStringColumn', function(x, name)

{
  accessorFuns = list('data' = GeoDaStringColumn_data_get, 'GetData' = GeoDaStringColumn_GetData, 'SetData' = GeoDaStringColumn_SetData);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaStringColumn
# Start of accessor method for GeoDaStringColumn
setMethod('$<-', '_p_GeoDaStringColumn', function(x, name, value)

{
  accessorFuns = list('data' = GeoDaStringColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaStringColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = GeoDaStringColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaStringColumn
setMethod('delete', '_p_GeoDaStringColumn', function(obj) {delete_GeoDaStringColumn(obj)})
# Start of GeoDaRealColumn_data_set

`GeoDaRealColumn_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.numeric(s_data);
  ;.Call('R_swig_GeoDaRealColumn_data_set', self, s_data, PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_data_set`, 'returnType') = 'void'
attr(`GeoDaRealColumn_data_set`, "inputTypes") = c('_p_GeoDaRealColumn', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaRealColumn_data_set`) = c("SWIGFunction", class('GeoDaRealColumn_data_set'))

# Start of GeoDaRealColumn_data_get

`GeoDaRealColumn_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaRealColumn_data_get', self, PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_data_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`GeoDaRealColumn_data_get`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`GeoDaRealColumn_data_get`) = c("SWIGFunction", class('GeoDaRealColumn_data_get'))

# Start of GeoDaRealColumn_GetData

`GeoDaRealColumn_GetData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaRealColumn_GetData', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_GetData`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`GeoDaRealColumn_GetData`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`GeoDaRealColumn_GetData`) = c("SWIGFunction", class('GeoDaRealColumn_GetData'))

# Start of GeoDaRealColumn_SetData

`GeoDaRealColumn_SetData` = function(self, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  vals = as.numeric(vals);
  ;.Call('R_swig_GeoDaRealColumn_SetData', self, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_SetData`, 'returnType') = 'void'
attr(`GeoDaRealColumn_SetData`, "inputTypes") = c('_p_GeoDaRealColumn', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaRealColumn_SetData`) = c("SWIGFunction", class('GeoDaRealColumn_SetData'))

# Start of new_GeoDaRealColumn

`GeoDaRealColumn` = function(nm, vals)
{
  nm = as(nm, "character"); 
  vals = as.numeric(vals);
  ;ans = .Call('R_swig_new_GeoDaRealColumn', nm, vals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaRealColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaRealColumn)
  ans
  
}

attr(`GeoDaRealColumn`, 'returnType') = '_p_GeoDaRealColumn'
attr(`GeoDaRealColumn`, "inputTypes") = c('character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaRealColumn`) = c("SWIGFunction", class('GeoDaRealColumn'))

# Start of delete_GeoDaRealColumn

`delete_GeoDaRealColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaRealColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaRealColumn`, 'returnType') = 'void'
attr(`delete_GeoDaRealColumn`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`delete_GeoDaRealColumn`) = c("SWIGFunction", class('delete_GeoDaRealColumn'))

# Start of accessor method for GeoDaRealColumn
setMethod('$', '_p_GeoDaRealColumn', function(x, name)

{
  accessorFuns = list('data' = GeoDaRealColumn_data_get, 'GetData' = GeoDaRealColumn_GetData, 'SetData' = GeoDaRealColumn_SetData);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaRealColumn
# Start of accessor method for GeoDaRealColumn
setMethod('$<-', '_p_GeoDaRealColumn', function(x, name, value)

{
  accessorFuns = list('data' = GeoDaRealColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaRealColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = GeoDaRealColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaRealColumn
setMethod('delete', '_p_GeoDaRealColumn', function(obj) {delete_GeoDaRealColumn(obj)})
# Start of new_GeoDaTable

`GeoDaTable` = function()
{
  ;ans = .Call('R_swig_new_GeoDaTable', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaTable", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaTable)
  ans
  
}

attr(`GeoDaTable`, 'returnType') = '_p_GeoDaTable'
class(`GeoDaTable`) = c("SWIGFunction", class('GeoDaTable'))

# Start of delete_GeoDaTable

`delete_GeoDaTable` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaTable', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaTable`, 'returnType') = 'void'
attr(`delete_GeoDaTable`, "inputTypes") = c('_p_GeoDaTable')
class(`delete_GeoDaTable`) = c("SWIGFunction", class('delete_GeoDaTable'))

# Start of GeoDaTable_AddIntColumn

`GeoDaTable_AddIntColumn__SWIG_0` = function(self, nm, vals, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  vals = as.integer(vals);
  undefs = as.logical(undefs);
  ;.Call('R_swig_GeoDaTable_AddIntColumn__SWIG_0', self, nm, vals, undefs, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddIntColumn__SWIG_0`, 'returnType') = 'void'
attr(`GeoDaTable_AddIntColumn__SWIG_0`, "inputTypes") = c('_p_GeoDaTable', 'character', 'integer', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDaTable_AddIntColumn__SWIG_0`) = c("SWIGFunction", class('GeoDaTable_AddIntColumn__SWIG_0'))

# Start of GeoDaTable_AddIntColumn

`GeoDaTable_AddIntColumn__SWIG_1` = function(self, nm, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  vals = as.integer(vals);
  ;.Call('R_swig_GeoDaTable_AddIntColumn__SWIG_1', self, nm, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddIntColumn__SWIG_1`, 'returnType') = 'void'
attr(`GeoDaTable_AddIntColumn__SWIG_1`, "inputTypes") = c('_p_GeoDaTable', 'character', 'integer')
class(`GeoDaTable_AddIntColumn__SWIG_1`) = c("SWIGFunction", class('GeoDaTable_AddIntColumn__SWIG_1'))

`GeoDaTable_AddIntColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- GeoDaTable_AddIntColumn__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) ) && ( is.logical(argv[[4]]) )) {
      f <- GeoDaTable_AddIntColumn__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaTable_AddIntColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaTable_AddStringColumn

`GeoDaTable_AddStringColumn__SWIG_0` = function(self, nm, vals, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  if (inherits(vals, "ExternalReference")) vals = slot(vals,"ref") 
  undefs = as.logical(undefs);
  ;.Call('R_swig_GeoDaTable_AddStringColumn__SWIG_0', self, nm, vals, undefs, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddStringColumn__SWIG_0`, 'returnType') = 'void'
attr(`GeoDaTable_AddStringColumn__SWIG_0`, "inputTypes") = c('_p_GeoDaTable', 'character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDaTable_AddStringColumn__SWIG_0`) = c("SWIGFunction", class('GeoDaTable_AddStringColumn__SWIG_0'))

# Start of GeoDaTable_AddStringColumn

`GeoDaTable_AddStringColumn__SWIG_1` = function(self, nm, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  if (inherits(vals, "ExternalReference")) vals = slot(vals,"ref") 
  ;.Call('R_swig_GeoDaTable_AddStringColumn__SWIG_1', self, nm, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddStringColumn__SWIG_1`, 'returnType') = 'void'
attr(`GeoDaTable_AddStringColumn__SWIG_1`, "inputTypes") = c('_p_GeoDaTable', 'character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaTable_AddStringColumn__SWIG_1`) = c("SWIGFunction", class('GeoDaTable_AddStringColumn__SWIG_1'))

`GeoDaTable_AddStringColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[3]]) == 1) {
      f <- GeoDaTable_AddStringColumn__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[3]]) == 1 && ( is.logical(argv[[4]]) )) {
      f <- GeoDaTable_AddStringColumn__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaTable_AddStringColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaTable_AddRealColumn

`GeoDaTable_AddRealColumn__SWIG_0` = function(self, nm, vals, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  vals = as.numeric(vals);
  undefs = as.logical(undefs);
  ;.Call('R_swig_GeoDaTable_AddRealColumn__SWIG_0', self, nm, vals, undefs, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddRealColumn__SWIG_0`, 'returnType') = 'void'
attr(`GeoDaTable_AddRealColumn__SWIG_0`, "inputTypes") = c('_p_GeoDaTable', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDaTable_AddRealColumn__SWIG_0`) = c("SWIGFunction", class('GeoDaTable_AddRealColumn__SWIG_0'))

# Start of GeoDaTable_AddRealColumn

`GeoDaTable_AddRealColumn__SWIG_1` = function(self, nm, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  vals = as.numeric(vals);
  ;.Call('R_swig_GeoDaTable_AddRealColumn__SWIG_1', self, nm, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddRealColumn__SWIG_1`, 'returnType') = 'void'
attr(`GeoDaTable_AddRealColumn__SWIG_1`, "inputTypes") = c('_p_GeoDaTable', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaTable_AddRealColumn__SWIG_1`) = c("SWIGFunction", class('GeoDaTable_AddRealColumn__SWIG_1'))

`GeoDaTable_AddRealColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) )) {
      f <- GeoDaTable_AddRealColumn__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) ) && ( is.logical(argv[[4]]) )) {
      f <- GeoDaTable_AddRealColumn__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaTable_AddRealColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaTable_GetColumn

`GeoDaTable_GetColumn__SWIG_0` = function(self, col_name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;ans = .Call('R_swig_GeoDaTable_GetColumn__SWIG_0', self, col_name, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`GeoDaTable_GetColumn__SWIG_0`, 'returnType') = '_p_GeoDaColumn'
attr(`GeoDaTable_GetColumn__SWIG_0`, "inputTypes") = c('_p_GeoDaTable', 'character')
class(`GeoDaTable_GetColumn__SWIG_0`) = c("SWIGFunction", class('GeoDaTable_GetColumn__SWIG_0'))

# Start of GeoDaTable_GetColumn

`GeoDaTable_GetColumn__SWIG_1` = function(self, idx)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  idx = as.integer(idx);
  
  if(length(idx) > 1) {
    warning("using only the first element of idx");
  };
  
  ;ans = .Call('R_swig_GeoDaTable_GetColumn__SWIG_1', self, idx, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`GeoDaTable_GetColumn__SWIG_1`, 'returnType') = '_p_GeoDaColumn'
attr(`GeoDaTable_GetColumn__SWIG_1`, "inputTypes") = c('_p_GeoDaTable', 'integer')
class(`GeoDaTable_GetColumn__SWIG_1`) = c("SWIGFunction", class('GeoDaTable_GetColumn__SWIG_1'))

`GeoDaTable_GetColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- GeoDaTable_GetColumn__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- GeoDaTable_GetColumn__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaTable_GetColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaTable_GetNumCols

`GeoDaTable_GetNumCols` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaTable_GetNumCols', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_GetNumCols`, 'returnType') = 'integer'
attr(`GeoDaTable_GetNumCols`, "inputTypes") = c('_p_GeoDaTable')
class(`GeoDaTable_GetNumCols`) = c("SWIGFunction", class('GeoDaTable_GetNumCols'))

# Start of accessor method for GeoDaTable
setMethod('$', '_p_GeoDaTable', function(x, name)

{
  accessorFuns = list('AddIntColumn' = GeoDaTable_AddIntColumn, 'AddStringColumn' = GeoDaTable_AddStringColumn, 'AddRealColumn' = GeoDaTable_AddRealColumn, 'GetColumn' = GeoDaTable_GetColumn, 'GetNumCols' = GeoDaTable_GetNumCols);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for GeoDaTable
setMethod('delete', '_p_GeoDaTable', function(obj) {delete_GeoDaTable(obj)})
# Start of GeoDa_point_type_get

`GeoDa_point_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDa_point_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_point_type_get`, 'returnType') = 'character'
class(`GeoDa_point_type_get`) = c("SWIGFunction", class('GeoDa_point_type_get'))

# Start of GeoDa_polygon_type_get

`GeoDa_polygon_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDa_polygon_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_polygon_type_get`, 'returnType') = 'character'
class(`GeoDa_polygon_type_get`) = c("SWIGFunction", class('GeoDa_polygon_type_get'))

# Start of GeoDa_line_type_get

`GeoDa_line_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDa_line_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_line_type_get`, 'returnType') = 'character'
class(`GeoDa_line_type_get`) = c("SWIGFunction", class('GeoDa_line_type_get'))

# Start of GeoDa_unknown_type_get

`GeoDa_unknown_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDa_unknown_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_unknown_type_get`, 'returnType') = 'character'
class(`GeoDa_unknown_type_get`) = c("SWIGFunction", class('GeoDa_unknown_type_get'))

# Start of new_GeoDa

`GeoDa__SWIG_0` = function(table, layer_name, map_type, wkbs, wkb_bytes_len, pszProj4)
{
  if (inherits(table, "ExternalReference")) table = slot(table,"ref") 
  layer_name = as(layer_name, "character"); 
  map_type = as(map_type, "character"); 
  wkbs = as.integer(wkbs);
  wkb_bytes_len = as.integer(wkb_bytes_len);
  pszProj4 = as(pszProj4, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_0', table, layer_name, map_type, wkbs, wkb_bytes_len, pszProj4, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_0`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_0`, "inputTypes") = c('_p_GeoDaTable', 'character', 'character', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t', 'character')
class(`GeoDa__SWIG_0`) = c("SWIGFunction", class('GeoDa__SWIG_0'))

# Start of new_GeoDa

`GeoDa__SWIG_1` = function(layer_name, map_type, num_features, table, wkbs, wkb_bytes_len, pszProj4)
{
  layer_name = as(layer_name, "character"); 
  map_type = as(map_type, "character"); 
  num_features = as.integer(num_features);
  
  if(length(num_features) > 1) {
    warning("using only the first element of num_features");
  };
  
  if (inherits(table, "ExternalReference")) table = slot(table,"ref") 
  wkbs = as.integer(wkbs);
  wkb_bytes_len = as.integer(wkb_bytes_len);
  pszProj4 = as(pszProj4, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_1', layer_name, map_type, num_features, table, wkbs, wkb_bytes_len, pszProj4, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_1`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_1`, "inputTypes") = c('character', 'character', 'integer', '_p_GeoDaTable', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t', 'character')
class(`GeoDa__SWIG_1`) = c("SWIGFunction", class('GeoDa__SWIG_1'))

# Start of new_GeoDa

`GeoDa__SWIG_2` = function(pDsPath, layer_name)
{
  pDsPath = as(pDsPath, "character"); 
  layer_name = as(layer_name, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_2', pDsPath, layer_name, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_2`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_2`, "inputTypes") = c('character', 'character')
class(`GeoDa__SWIG_2`) = c("SWIGFunction", class('GeoDa__SWIG_2'))

# Start of new_GeoDa

`GeoDa__SWIG_3` = function(pDsPath)
{
  pDsPath = as(pDsPath, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_3', pDsPath, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_3`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_3`, "inputTypes") = c('character')
class(`GeoDa__SWIG_3`) = c("SWIGFunction", class('GeoDa__SWIG_3'))

`GeoDa` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- GeoDa__SWIG_3; 
    }
  } else if (argc == 2) {
    if (is.character(argv[[1]]) && is.character(argv[[2]])) {
      f <- GeoDa__SWIG_2; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.integer(argv[[4]]) || is.numeric(argv[[4]]) ) && ( is.integer(argv[[5]]) || is.numeric(argv[[5]]) ) && is.character(argv[[6]]) && length(argv[[6]]) == 1) {
      f <- GeoDa__SWIG_0; 
    }
  } else if (argc == 7) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && (extends(argtypes[4], '_p_GeoDaTable') || is.null(argv[[4]])) && ( is.integer(argv[[5]]) || is.numeric(argv[[5]]) ) && ( is.integer(argv[[6]]) || is.numeric(argv[[6]]) ) && is.character(argv[[7]]) && length(argv[[7]]) == 1) {
      f <- GeoDa__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_GeoDa

`delete_GeoDa` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDa', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDa`, 'returnType') = 'void'
attr(`delete_GeoDa`, "inputTypes") = c('_p_GeoDa')
class(`delete_GeoDa`) = c("SWIGFunction", class('delete_GeoDa'))

# Start of GeoDa_GetNumObs

`GeoDa_GetNumObs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetNumObs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetNumObs`, 'returnType') = 'integer'
attr(`GeoDa_GetNumObs`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetNumObs`) = c("SWIGFunction", class('GeoDa_GetNumObs'))

# Start of GeoDa_GetCentroids

`GeoDa_GetCentroids` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDa_GetCentroids', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_gda__PointContents_p_std__allocatorT_gda__PointContents_p_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDa_GetCentroids`, 'returnType') = '_p_std__vectorT_gda__PointContents_p_std__allocatorT_gda__PointContents_p_t_t'
attr(`GeoDa_GetCentroids`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetCentroids`) = c("SWIGFunction", class('GeoDa_GetCentroids'))

# Start of GeoDa_GetMapType

`GeoDa_GetMapType` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetMapType', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetMapType`, 'returnType') = 'integer'
attr(`GeoDa_GetMapType`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetMapType`) = c("SWIGFunction", class('GeoDa_GetMapType'))

# Start of GeoDa_GetMainMap

`GeoDa_GetMainMap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDa_GetMainMap', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_gda__MainMap", ref=ans);
  
  ans
  
}

attr(`GeoDa_GetMainMap`, 'returnType') = '_p_gda__MainMap'
attr(`GeoDa_GetMainMap`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetMainMap`) = c("SWIGFunction", class('GeoDa_GetMainMap'))

# Start of GeoDa_GetNumCols

`GeoDa_GetNumCols` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetNumCols', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetNumCols`, 'returnType') = 'integer'
attr(`GeoDa_GetNumCols`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetNumCols`) = c("SWIGFunction", class('GeoDa_GetNumCols'))

# Start of GeoDa_GetFieldTypes

`GeoDa_GetFieldTypes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetFieldTypes', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetFieldTypes`, 'returnType') = 'character'
attr(`GeoDa_GetFieldTypes`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetFieldTypes`) = c("SWIGFunction", class('GeoDa_GetFieldTypes'))

# Start of GeoDa_GetFieldNames

`GeoDa_GetFieldNames` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetFieldNames', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetFieldNames`, 'returnType') = 'character'
attr(`GeoDa_GetFieldNames`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetFieldNames`) = c("SWIGFunction", class('GeoDa_GetFieldNames'))

# Start of GeoDa_GetNumericCol

`GeoDa_GetNumericCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetNumericCol', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetNumericCol`, 'returnType') = 'numeric'
attr(`GeoDa_GetNumericCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetNumericCol`) = c("SWIGFunction", class('GeoDa_GetNumericCol'))

# Start of GeoDa_GetIntegerCol

`GeoDa_GetIntegerCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetIntegerCol', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetIntegerCol`, 'returnType') = 'integer'
attr(`GeoDa_GetIntegerCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetIntegerCol`) = c("SWIGFunction", class('GeoDa_GetIntegerCol'))

# Start of GeoDa_GetStringCol

`GeoDa_GetStringCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetStringCol', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetStringCol`, 'returnType') = 'character'
attr(`GeoDa_GetStringCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetStringCol`) = c("SWIGFunction", class('GeoDa_GetStringCol'))

# Start of GeoDa_GetNullValues

`GeoDa_GetNullValues` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetNullValues', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetNullValues`, 'returnType') = 'logical'
attr(`GeoDa_GetNullValues`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetNullValues`) = c("SWIGFunction", class('GeoDa_GetNullValues'))

# Start of accessor method for GeoDa
setMethod('$', '_p_GeoDa', function(x, name)

{
  accessorFuns = list('GetNumObs' = GeoDa_GetNumObs, 'GetCentroids' = GeoDa_GetCentroids, 'GetMapType' = GeoDa_GetMapType, 'GetMainMap' = GeoDa_GetMainMap, 'GetNumCols' = GeoDa_GetNumCols, 'GetFieldTypes' = GeoDa_GetFieldTypes, 'GetFieldNames' = GeoDa_GetFieldNames, 'GetNumericCol' = GeoDa_GetNumericCol, 'GetIntegerCol' = GeoDa_GetIntegerCol, 'GetStringCol' = GeoDa_GetStringCol, 'GetNullValues' = GeoDa_GetNullValues);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for GeoDa
setMethod('delete', '_p_GeoDa', function(obj) {delete_GeoDa(obj)})
# Start of test

`test` = function(.copy = FALSE)
{
  ;.Call('R_swig_test', as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`test`, 'returnType') = 'integer'
class(`test`) = c("SWIGFunction", class('test'))

# Start of ToGeoDaColumn

`ToGeoDaColumn__SWIG_0` = function(col)
{
  if (inherits(col, "ExternalReference")) col = slot(col,"ref") 
  ;ans = .Call('R_swig_ToGeoDaColumn__SWIG_0', col, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`ToGeoDaColumn__SWIG_0`, 'returnType') = '_p_GeoDaColumn'
attr(`ToGeoDaColumn__SWIG_0`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`ToGeoDaColumn__SWIG_0`) = c("SWIGFunction", class('ToGeoDaColumn__SWIG_0'))

# Start of ToGeoDaColumn

`ToGeoDaColumn__SWIG_1` = function(col)
{
  if (inherits(col, "ExternalReference")) col = slot(col,"ref") 
  ;ans = .Call('R_swig_ToGeoDaColumn__SWIG_1', col, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`ToGeoDaColumn__SWIG_1`, 'returnType') = '_p_GeoDaColumn'
attr(`ToGeoDaColumn__SWIG_1`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`ToGeoDaColumn__SWIG_1`) = c("SWIGFunction", class('ToGeoDaColumn__SWIG_1'))

# Start of ToGeoDaColumn

`ToGeoDaColumn__SWIG_2` = function(col)
{
  if (inherits(col, "ExternalReference")) col = slot(col,"ref") 
  ;ans = .Call('R_swig_ToGeoDaColumn__SWIG_2', col, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`ToGeoDaColumn__SWIG_2`, 'returnType') = '_p_GeoDaColumn'
attr(`ToGeoDaColumn__SWIG_2`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`ToGeoDaColumn__SWIG_2`) = c("SWIGFunction", class('ToGeoDaColumn__SWIG_2'))

`ToGeoDaColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_GeoDaStringColumn') || is.null(argv[[1]]))) {
      f <- ToGeoDaColumn__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaIntColumn') || is.null(argv[[1]]))) {
      f <- ToGeoDaColumn__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaRealColumn') || is.null(argv[[1]]))) {
      f <- ToGeoDaColumn__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for ToGeoDaColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_localmoran

`gda_localmoran__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_localmoran__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localmoran__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_localmoran__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', 'integer')
class(`gda_localmoran__SWIG_0`) = c("SWIGFunction", class('gda_localmoran__SWIG_0'))

# Start of gda_localmoran

`gda_localmoran__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_localmoran__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localmoran__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_localmoran__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`gda_localmoran__SWIG_1`) = c("SWIGFunction", class('gda_localmoran__SWIG_1'))

# Start of gda_localmoran

`gda_localmoran__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_localmoran__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localmoran__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_localmoran__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`gda_localmoran__SWIG_2`) = c("SWIGFunction", class('gda_localmoran__SWIG_2'))

# Start of gda_localmoran

`gda_localmoran__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_gda_localmoran__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localmoran__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_localmoran__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_localmoran__SWIG_3`) = c("SWIGFunction", class('gda_localmoran__SWIG_3'))

# Start of gda_localmoran

`gda_localmoran__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  ;ans = .Call('R_swig_gda_localmoran__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localmoran__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_localmoran__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_localmoran__SWIG_4`) = c("SWIGFunction", class('gda_localmoran__SWIG_4'))

`gda_localmoran` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) )) {
      f <- gda_localmoran__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) )) {
      f <- gda_localmoran__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_localmoran__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_localmoran__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_localmoran__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_localmoran with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_batchlocalmoran

`gda_batchlocalmoran__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_batchlocalmoran__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_BatchLISA", ref=ans);
  
  ans
  
}

attr(`gda_batchlocalmoran__SWIG_0`, 'returnType') = '_p_BatchLISA'
attr(`gda_batchlocalmoran__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer', 'integer', 'integer')
class(`gda_batchlocalmoran__SWIG_0`) = c("SWIGFunction", class('gda_batchlocalmoran__SWIG_0'))

# Start of gda_batchlocalmoran

`gda_batchlocalmoran__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_batchlocalmoran__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_BatchLISA", ref=ans);
  
  ans
  
}

attr(`gda_batchlocalmoran__SWIG_1`, 'returnType') = '_p_BatchLISA'
attr(`gda_batchlocalmoran__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer', 'integer')
class(`gda_batchlocalmoran__SWIG_1`) = c("SWIGFunction", class('gda_batchlocalmoran__SWIG_1'))

# Start of gda_batchlocalmoran

`gda_batchlocalmoran__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_batchlocalmoran__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_BatchLISA", ref=ans);
  
  ans
  
}

attr(`gda_batchlocalmoran__SWIG_2`, 'returnType') = '_p_BatchLISA'
attr(`gda_batchlocalmoran__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer')
class(`gda_batchlocalmoran__SWIG_2`) = c("SWIGFunction", class('gda_batchlocalmoran__SWIG_2'))

# Start of gda_batchlocalmoran

`gda_batchlocalmoran__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  ;ans = .Call('R_swig_gda_batchlocalmoran__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_BatchLISA", ref=ans);
  
  ans
  
}

attr(`gda_batchlocalmoran__SWIG_3`, 'returnType') = '_p_BatchLISA'
attr(`gda_batchlocalmoran__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list')
class(`gda_batchlocalmoran__SWIG_3`) = c("SWIGFunction", class('gda_batchlocalmoran__SWIG_3'))

# Start of gda_batchlocalmoran

`gda_batchlocalmoran__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  ;ans = .Call('R_swig_gda_batchlocalmoran__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_BatchLISA", ref=ans);
  
  ans
  
}

attr(`gda_batchlocalmoran__SWIG_4`, 'returnType') = '_p_BatchLISA'
attr(`gda_batchlocalmoran__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', 'list')
class(`gda_batchlocalmoran__SWIG_4`) = c("SWIGFunction", class('gda_batchlocalmoran__SWIG_4'))

`gda_batchlocalmoran` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) )) {
      f <- gda_batchlocalmoran__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) )) {
      f <- gda_batchlocalmoran__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_batchlocalmoran__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_batchlocalmoran__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_batchlocalmoran__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_batchlocalmoran with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_geary

`gda_geary__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_geary__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_geary__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_geary__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', 'integer')
class(`gda_geary__SWIG_0`) = c("SWIGFunction", class('gda_geary__SWIG_0'))

# Start of gda_geary

`gda_geary__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_geary__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_geary__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_geary__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`gda_geary__SWIG_1`) = c("SWIGFunction", class('gda_geary__SWIG_1'))

# Start of gda_geary

`gda_geary__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_geary__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_geary__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_geary__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`gda_geary__SWIG_2`) = c("SWIGFunction", class('gda_geary__SWIG_2'))

# Start of gda_geary

`gda_geary__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_gda_geary__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_geary__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_geary__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_geary__SWIG_3`) = c("SWIGFunction", class('gda_geary__SWIG_3'))

# Start of gda_geary

`gda_geary__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  ;ans = .Call('R_swig_gda_geary__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_geary__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_geary__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_geary__SWIG_4`) = c("SWIGFunction", class('gda_geary__SWIG_4'))

`gda_geary` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) )) {
      f <- gda_geary__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) )) {
      f <- gda_geary__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_geary__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_geary__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_geary__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_geary with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_multigeary

`gda_multigeary__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_multigeary__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multigeary__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_multigeary__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer', 'integer', 'integer')
class(`gda_multigeary__SWIG_0`) = c("SWIGFunction", class('gda_multigeary__SWIG_0'))

# Start of gda_multigeary

`gda_multigeary__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_multigeary__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multigeary__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_multigeary__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer', 'integer')
class(`gda_multigeary__SWIG_1`) = c("SWIGFunction", class('gda_multigeary__SWIG_1'))

# Start of gda_multigeary

`gda_multigeary__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_multigeary__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multigeary__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_multigeary__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer')
class(`gda_multigeary__SWIG_2`) = c("SWIGFunction", class('gda_multigeary__SWIG_2'))

# Start of gda_multigeary

`gda_multigeary__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  ;ans = .Call('R_swig_gda_multigeary__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multigeary__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_multigeary__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list')
class(`gda_multigeary__SWIG_3`) = c("SWIGFunction", class('gda_multigeary__SWIG_3'))

# Start of gda_multigeary

`gda_multigeary__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  ;ans = .Call('R_swig_gda_multigeary__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multigeary__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_multigeary__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', 'list')
class(`gda_multigeary__SWIG_4`) = c("SWIGFunction", class('gda_multigeary__SWIG_4'))

`gda_multigeary` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) )) {
      f <- gda_multigeary__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) )) {
      f <- gda_multigeary__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_multigeary__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_multigeary__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_multigeary__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_multigeary with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_joincount

`gda_joincount__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_joincount__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_joincount__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_joincount__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', 'integer')
class(`gda_joincount__SWIG_0`) = c("SWIGFunction", class('gda_joincount__SWIG_0'))

# Start of gda_joincount

`gda_joincount__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_joincount__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_joincount__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_joincount__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`gda_joincount__SWIG_1`) = c("SWIGFunction", class('gda_joincount__SWIG_1'))

# Start of gda_joincount

`gda_joincount__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_joincount__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_joincount__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_joincount__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`gda_joincount__SWIG_2`) = c("SWIGFunction", class('gda_joincount__SWIG_2'))

# Start of gda_joincount

`gda_joincount__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_gda_joincount__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_joincount__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_joincount__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_joincount__SWIG_3`) = c("SWIGFunction", class('gda_joincount__SWIG_3'))

# Start of gda_joincount

`gda_joincount__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  ;ans = .Call('R_swig_gda_joincount__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_joincount__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_joincount__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_joincount__SWIG_4`) = c("SWIGFunction", class('gda_joincount__SWIG_4'))

`gda_joincount` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) )) {
      f <- gda_joincount__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) )) {
      f <- gda_joincount__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_joincount__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_joincount__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_joincount__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_joincount with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_multijoincount

`gda_multijoincount__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_multijoincount__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multijoincount__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_multijoincount__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer', 'integer', 'integer')
class(`gda_multijoincount__SWIG_0`) = c("SWIGFunction", class('gda_multijoincount__SWIG_0'))

# Start of gda_multijoincount

`gda_multijoincount__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_multijoincount__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multijoincount__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_multijoincount__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer', 'integer')
class(`gda_multijoincount__SWIG_1`) = c("SWIGFunction", class('gda_multijoincount__SWIG_1'))

# Start of gda_multijoincount

`gda_multijoincount__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_multijoincount__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multijoincount__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_multijoincount__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list', 'integer')
class(`gda_multijoincount__SWIG_2`) = c("SWIGFunction", class('gda_multijoincount__SWIG_2'))

# Start of gda_multijoincount

`gda_multijoincount__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  undefs = lapply(undefs, as.logical);
  ;ans = .Call('R_swig_gda_multijoincount__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multijoincount__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_multijoincount__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', 'list', 'list')
class(`gda_multijoincount__SWIG_3`) = c("SWIGFunction", class('gda_multijoincount__SWIG_3'))

# Start of gda_multijoincount

`gda_multijoincount__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  ;ans = .Call('R_swig_gda_multijoincount__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_multijoincount__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_multijoincount__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', 'list')
class(`gda_multijoincount__SWIG_4`) = c("SWIGFunction", class('gda_multijoincount__SWIG_4'))

`gda_multijoincount` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) )) {
      f <- gda_multijoincount__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) )) {
      f <- gda_multijoincount__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_multijoincount__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_multijoincount__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_multijoincount__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_multijoincount with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_localg

`gda_localg__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_localg__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localg__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_localg__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', 'integer')
class(`gda_localg__SWIG_0`) = c("SWIGFunction", class('gda_localg__SWIG_0'))

# Start of gda_localg

`gda_localg__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_localg__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localg__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_localg__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`gda_localg__SWIG_1`) = c("SWIGFunction", class('gda_localg__SWIG_1'))

# Start of gda_localg

`gda_localg__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_localg__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localg__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_localg__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`gda_localg__SWIG_2`) = c("SWIGFunction", class('gda_localg__SWIG_2'))

# Start of gda_localg

`gda_localg__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_gda_localg__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localg__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_localg__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_localg__SWIG_3`) = c("SWIGFunction", class('gda_localg__SWIG_3'))

# Start of gda_localg

`gda_localg__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  ;ans = .Call('R_swig_gda_localg__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localg__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_localg__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_localg__SWIG_4`) = c("SWIGFunction", class('gda_localg__SWIG_4'))

`gda_localg` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) )) {
      f <- gda_localg__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) )) {
      f <- gda_localg__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_localg__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_localg__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_localg__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_localg with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_localgstar

`gda_localgstar__SWIG_0` = function(w, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_localgstar__SWIG_0', w, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localgstar__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_localgstar__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', 'integer')
class(`gda_localgstar__SWIG_0`) = c("SWIGFunction", class('gda_localgstar__SWIG_0'))

# Start of gda_localgstar

`gda_localgstar__SWIG_1` = function(w, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_localgstar__SWIG_1', w, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localgstar__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_localgstar__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`gda_localgstar__SWIG_1`) = c("SWIGFunction", class('gda_localgstar__SWIG_1'))

# Start of gda_localgstar

`gda_localgstar__SWIG_2` = function(w, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_localgstar__SWIG_2', w, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localgstar__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_localgstar__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`gda_localgstar__SWIG_2`) = c("SWIGFunction", class('gda_localgstar__SWIG_2'))

# Start of gda_localgstar

`gda_localgstar__SWIG_3` = function(w, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_gda_localgstar__SWIG_3', w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localgstar__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_localgstar__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_localgstar__SWIG_3`) = c("SWIGFunction", class('gda_localgstar__SWIG_3'))

# Start of gda_localgstar

`gda_localgstar__SWIG_4` = function(w, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  ;ans = .Call('R_swig_gda_localgstar__SWIG_4', w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_localgstar__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_localgstar__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_localgstar__SWIG_4`) = c("SWIGFunction", class('gda_localgstar__SWIG_4'))

`gda_localgstar` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) )) {
      f <- gda_localgstar__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) )) {
      f <- gda_localgstar__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- gda_localgstar__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_localgstar__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_localgstar__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_localgstar with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_quantilelisa

`gda_quantilelisa__SWIG_0` = function(w, k, quantile, data, undefs, nCPUs, permutations, last_seed_used)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  quantile = as.integer(quantile);
  
  if(length(quantile) > 1) {
    warning("using only the first element of quantile");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  last_seed_used = as.integer(last_seed_used);
  
  if(length(last_seed_used) > 1) {
    warning("using only the first element of last_seed_used");
  };
  
  ;ans = .Call('R_swig_gda_quantilelisa__SWIG_0', w, k, quantile, data, undefs, nCPUs, permutations, last_seed_used, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_quantilelisa__SWIG_0`, 'returnType') = '_p_LISA'
attr(`gda_quantilelisa__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer', 'integer')
class(`gda_quantilelisa__SWIG_0`) = c("SWIGFunction", class('gda_quantilelisa__SWIG_0'))

# Start of gda_quantilelisa

`gda_quantilelisa__SWIG_1` = function(w, k, quantile, data, undefs, nCPUs, permutations)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  quantile = as.integer(quantile);
  
  if(length(quantile) > 1) {
    warning("using only the first element of quantile");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  permutations = as.integer(permutations);
  
  if(length(permutations) > 1) {
    warning("using only the first element of permutations");
  };
  
  ;ans = .Call('R_swig_gda_quantilelisa__SWIG_1', w, k, quantile, data, undefs, nCPUs, permutations, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_quantilelisa__SWIG_1`, 'returnType') = '_p_LISA'
attr(`gda_quantilelisa__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer', 'integer')
class(`gda_quantilelisa__SWIG_1`) = c("SWIGFunction", class('gda_quantilelisa__SWIG_1'))

# Start of gda_quantilelisa

`gda_quantilelisa__SWIG_2` = function(w, k, quantile, data, undefs, nCPUs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  quantile = as.integer(quantile);
  
  if(length(quantile) > 1) {
    warning("using only the first element of quantile");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  nCPUs = as.integer(nCPUs);
  
  if(length(nCPUs) > 1) {
    warning("using only the first element of nCPUs");
  };
  
  ;ans = .Call('R_swig_gda_quantilelisa__SWIG_2', w, k, quantile, data, undefs, nCPUs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_quantilelisa__SWIG_2`, 'returnType') = '_p_LISA'
attr(`gda_quantilelisa__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', 'integer')
class(`gda_quantilelisa__SWIG_2`) = c("SWIGFunction", class('gda_quantilelisa__SWIG_2'))

# Start of gda_quantilelisa

`gda_quantilelisa__SWIG_3` = function(w, k, quantile, data, undefs)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  quantile = as.integer(quantile);
  
  if(length(quantile) > 1) {
    warning("using only the first element of quantile");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_gda_quantilelisa__SWIG_3', w, k, quantile, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_quantilelisa__SWIG_3`, 'returnType') = '_p_LISA'
attr(`gda_quantilelisa__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_quantilelisa__SWIG_3`) = c("SWIGFunction", class('gda_quantilelisa__SWIG_3'))

# Start of gda_quantilelisa

`gda_quantilelisa__SWIG_4` = function(w, k, quantile, data)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  quantile = as.integer(quantile);
  
  if(length(quantile) > 1) {
    warning("using only the first element of quantile");
  };
  
  data = as.numeric(data);
  ;ans = .Call('R_swig_gda_quantilelisa__SWIG_4', w, k, quantile, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_LISA", ref=ans);
  
  ans
  
}

attr(`gda_quantilelisa__SWIG_4`, 'returnType') = '_p_LISA'
attr(`gda_quantilelisa__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_quantilelisa__SWIG_4`) = c("SWIGFunction", class('gda_quantilelisa__SWIG_4'))

`gda_quantilelisa` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) )) {
      f <- gda_quantilelisa__SWIG_4; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) ) && ( is.logical(argv[[5]]) )) {
      f <- gda_quantilelisa__SWIG_3; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) ) && ( is.logical(argv[[5]]) ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_quantilelisa__SWIG_2; 
    }
  } else if (argc == 7) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) ) && ( is.logical(argv[[5]]) ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 )) {
      f <- gda_quantilelisa__SWIG_1; 
    }
  } else if (argc == 8) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) ) && ( is.logical(argv[[5]]) ) && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 ) && ( (is.integer(argv[[8]]) || is.numeric(argv[[8]])) && length(argv[[8]]) == 1 )) {
      f <- gda_quantilelisa__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_quantilelisa with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_fdr

`gda_fdr` = function(lisa, current_p, .copy = FALSE)
{
  if (inherits(lisa, "ExternalReference")) lisa = slot(lisa,"ref") 
  
  ;.Call('R_swig_gda_fdr', lisa, current_p, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_fdr`, 'returnType') = 'numeric'
attr(`gda_fdr`, "inputTypes") = c('_p_LISA', 'numeric')
class(`gda_fdr`) = c("SWIGFunction", class('gda_fdr'))

# Start of gda_bo

`gda_bo` = function(lisa, current_p, .copy = FALSE)
{
  if (inherits(lisa, "ExternalReference")) lisa = slot(lisa,"ref") 
  
  ;.Call('R_swig_gda_bo', lisa, current_p, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_bo`, 'returnType') = 'numeric'
attr(`gda_bo`, "inputTypes") = c('_p_LISA', 'numeric')
class(`gda_bo`) = c("SWIGFunction", class('gda_bo'))

# Start of gda_demean

`gda_demean` = function(data, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  ;.Call('R_swig_gda_demean', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_demean`, 'returnType') = 'list'
attr(`gda_demean`, "inputTypes") = c('list')
class(`gda_demean`) = c("SWIGFunction", class('gda_demean'))

# Start of gda_standardize

`gda_standardize` = function(data, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  ;.Call('R_swig_gda_standardize', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_standardize`, 'returnType') = 'list'
attr(`gda_standardize`, "inputTypes") = c('list')
class(`gda_standardize`) = c("SWIGFunction", class('gda_standardize'))

# Start of gda_standardize_mad

`gda_standardize_mad` = function(data, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  ;.Call('R_swig_gda_standardize_mad', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_standardize_mad`, 'returnType') = 'list'
attr(`gda_standardize_mad`, "inputTypes") = c('list')
class(`gda_standardize_mad`) = c("SWIGFunction", class('gda_standardize_mad'))

# Start of gda_naturalbreaks

`gda_naturalbreaks__SWIG_0` = function(k, data, undefs, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;.Call('R_swig_gda_naturalbreaks__SWIG_0', k, data, undefs, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_naturalbreaks__SWIG_0`, 'returnType') = 'numeric'
attr(`gda_naturalbreaks__SWIG_0`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_naturalbreaks__SWIG_0`) = c("SWIGFunction", class('gda_naturalbreaks__SWIG_0'))

# Start of gda_naturalbreaks

`gda_naturalbreaks__SWIG_1` = function(k, data, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  data = as.numeric(data);
  ;.Call('R_swig_gda_naturalbreaks__SWIG_1', k, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_naturalbreaks__SWIG_1`, 'returnType') = 'numeric'
attr(`gda_naturalbreaks__SWIG_1`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_naturalbreaks__SWIG_1`) = c("SWIGFunction", class('gda_naturalbreaks__SWIG_1'))

`gda_naturalbreaks` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) )) {
      f <- gda_naturalbreaks__SWIG_1; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) )) {
      f <- gda_naturalbreaks__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_naturalbreaks with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_quantilebreaks

`gda_quantilebreaks__SWIG_0` = function(k, data, undefs, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;.Call('R_swig_gda_quantilebreaks__SWIG_0', k, data, undefs, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_quantilebreaks__SWIG_0`, 'returnType') = 'numeric'
attr(`gda_quantilebreaks__SWIG_0`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_quantilebreaks__SWIG_0`) = c("SWIGFunction", class('gda_quantilebreaks__SWIG_0'))

# Start of gda_quantilebreaks

`gda_quantilebreaks__SWIG_1` = function(k, data, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  data = as.numeric(data);
  ;.Call('R_swig_gda_quantilebreaks__SWIG_1', k, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_quantilebreaks__SWIG_1`, 'returnType') = 'numeric'
attr(`gda_quantilebreaks__SWIG_1`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_quantilebreaks__SWIG_1`) = c("SWIGFunction", class('gda_quantilebreaks__SWIG_1'))

`gda_quantilebreaks` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) )) {
      f <- gda_quantilebreaks__SWIG_1; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) )) {
      f <- gda_quantilebreaks__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_quantilebreaks with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_hinge15breaks

`gda_hinge15breaks__SWIG_0` = function(data, undefs, .copy = FALSE)
{
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;.Call('R_swig_gda_hinge15breaks__SWIG_0', data, undefs, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_hinge15breaks__SWIG_0`, 'returnType') = 'numeric'
attr(`gda_hinge15breaks__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_hinge15breaks__SWIG_0`) = c("SWIGFunction", class('gda_hinge15breaks__SWIG_0'))

# Start of gda_hinge15breaks

`gda_hinge15breaks__SWIG_1` = function(data, .copy = FALSE)
{
  data = as.numeric(data);
  ;.Call('R_swig_gda_hinge15breaks__SWIG_1', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_hinge15breaks__SWIG_1`, 'returnType') = 'numeric'
attr(`gda_hinge15breaks__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_hinge15breaks__SWIG_1`) = c("SWIGFunction", class('gda_hinge15breaks__SWIG_1'))

`gda_hinge15breaks` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (( is.numeric(argv[[1]]) )) {
      f <- gda_hinge15breaks__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( is.logical(argv[[2]]) )) {
      f <- gda_hinge15breaks__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_hinge15breaks with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_hinge30breaks

`gda_hinge30breaks__SWIG_0` = function(data, undefs, .copy = FALSE)
{
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;.Call('R_swig_gda_hinge30breaks__SWIG_0', data, undefs, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_hinge30breaks__SWIG_0`, 'returnType') = 'numeric'
attr(`gda_hinge30breaks__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_hinge30breaks__SWIG_0`) = c("SWIGFunction", class('gda_hinge30breaks__SWIG_0'))

# Start of gda_hinge30breaks

`gda_hinge30breaks__SWIG_1` = function(data, .copy = FALSE)
{
  data = as.numeric(data);
  ;.Call('R_swig_gda_hinge30breaks__SWIG_1', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_hinge30breaks__SWIG_1`, 'returnType') = 'numeric'
attr(`gda_hinge30breaks__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_hinge30breaks__SWIG_1`) = c("SWIGFunction", class('gda_hinge30breaks__SWIG_1'))

`gda_hinge30breaks` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (( is.numeric(argv[[1]]) )) {
      f <- gda_hinge30breaks__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( is.logical(argv[[2]]) )) {
      f <- gda_hinge30breaks__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_hinge30breaks with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_percentilebreaks

`gda_percentilebreaks__SWIG_0` = function(data, undefs, .copy = FALSE)
{
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;.Call('R_swig_gda_percentilebreaks__SWIG_0', data, undefs, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_percentilebreaks__SWIG_0`, 'returnType') = 'numeric'
attr(`gda_percentilebreaks__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_percentilebreaks__SWIG_0`) = c("SWIGFunction", class('gda_percentilebreaks__SWIG_0'))

# Start of gda_percentilebreaks

`gda_percentilebreaks__SWIG_1` = function(data, .copy = FALSE)
{
  data = as.numeric(data);
  ;.Call('R_swig_gda_percentilebreaks__SWIG_1', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_percentilebreaks__SWIG_1`, 'returnType') = 'numeric'
attr(`gda_percentilebreaks__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_percentilebreaks__SWIG_1`) = c("SWIGFunction", class('gda_percentilebreaks__SWIG_1'))

`gda_percentilebreaks` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (( is.numeric(argv[[1]]) )) {
      f <- gda_percentilebreaks__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( is.logical(argv[[2]]) )) {
      f <- gda_percentilebreaks__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_percentilebreaks with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_stddevbreaks

`gda_stddevbreaks__SWIG_0` = function(data, undefs, .copy = FALSE)
{
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;.Call('R_swig_gda_stddevbreaks__SWIG_0', data, undefs, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_stddevbreaks__SWIG_0`, 'returnType') = 'numeric'
attr(`gda_stddevbreaks__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`gda_stddevbreaks__SWIG_0`) = c("SWIGFunction", class('gda_stddevbreaks__SWIG_0'))

# Start of gda_stddevbreaks

`gda_stddevbreaks__SWIG_1` = function(data, .copy = FALSE)
{
  data = as.numeric(data);
  ;.Call('R_swig_gda_stddevbreaks__SWIG_1', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_stddevbreaks__SWIG_1`, 'returnType') = 'numeric'
attr(`gda_stddevbreaks__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_stddevbreaks__SWIG_1`) = c("SWIGFunction", class('gda_stddevbreaks__SWIG_1'))

`gda_stddevbreaks` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (( is.numeric(argv[[1]]) )) {
      f <- gda_stddevbreaks__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( is.logical(argv[[2]]) )) {
      f <- gda_stddevbreaks__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_stddevbreaks with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_queen_weights

`gda_queen_weights__SWIG_0` = function(geoda, order, include_lower_order, precision_threshold)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  include_lower_order = as.logical(include_lower_order);
  
  ;ans = .Call('R_swig_gda_queen_weights__SWIG_0', geoda, order, include_lower_order, precision_threshold, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_queen_weights__SWIG_0`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_queen_weights__SWIG_0`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'logical', 'numeric')
class(`gda_queen_weights__SWIG_0`) = c("SWIGFunction", class('gda_queen_weights__SWIG_0'))

# Start of gda_queen_weights

`gda_queen_weights__SWIG_1` = function(geoda, order, include_lower_order)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  include_lower_order = as.logical(include_lower_order);
  ;ans = .Call('R_swig_gda_queen_weights__SWIG_1', geoda, order, include_lower_order, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_queen_weights__SWIG_1`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_queen_weights__SWIG_1`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'logical')
class(`gda_queen_weights__SWIG_1`) = c("SWIGFunction", class('gda_queen_weights__SWIG_1'))

# Start of gda_queen_weights

`gda_queen_weights__SWIG_2` = function(geoda, order)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  ;ans = .Call('R_swig_gda_queen_weights__SWIG_2', geoda, order, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_queen_weights__SWIG_2`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_queen_weights__SWIG_2`, "inputTypes") = c('_p_AbstractGeoDa', 'integer')
class(`gda_queen_weights__SWIG_2`) = c("SWIGFunction", class('gda_queen_weights__SWIG_2'))

# Start of gda_queen_weights

`gda_queen_weights__SWIG_3` = function(geoda)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  ;ans = .Call('R_swig_gda_queen_weights__SWIG_3', geoda, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_queen_weights__SWIG_3`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_queen_weights__SWIG_3`, "inputTypes") = c('_p_AbstractGeoDa')
class(`gda_queen_weights__SWIG_3`) = c("SWIGFunction", class('gda_queen_weights__SWIG_3'))

`gda_queen_weights` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]]))) {
      f <- gda_queen_weights__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- gda_queen_weights__SWIG_2; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- gda_queen_weights__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- gda_queen_weights__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_queen_weights with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_rook_weights

`gda_rook_weights__SWIG_0` = function(geoda, order, include_lower_order, precision_threshold)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  include_lower_order = as.logical(include_lower_order);
  
  ;ans = .Call('R_swig_gda_rook_weights__SWIG_0', geoda, order, include_lower_order, precision_threshold, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_rook_weights__SWIG_0`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_rook_weights__SWIG_0`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'logical', 'numeric')
class(`gda_rook_weights__SWIG_0`) = c("SWIGFunction", class('gda_rook_weights__SWIG_0'))

# Start of gda_rook_weights

`gda_rook_weights__SWIG_1` = function(geoda, order, include_lower_order)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  include_lower_order = as.logical(include_lower_order);
  ;ans = .Call('R_swig_gda_rook_weights__SWIG_1', geoda, order, include_lower_order, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_rook_weights__SWIG_1`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_rook_weights__SWIG_1`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'logical')
class(`gda_rook_weights__SWIG_1`) = c("SWIGFunction", class('gda_rook_weights__SWIG_1'))

# Start of gda_rook_weights

`gda_rook_weights__SWIG_2` = function(geoda, order)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  ;ans = .Call('R_swig_gda_rook_weights__SWIG_2', geoda, order, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_rook_weights__SWIG_2`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_rook_weights__SWIG_2`, "inputTypes") = c('_p_AbstractGeoDa', 'integer')
class(`gda_rook_weights__SWIG_2`) = c("SWIGFunction", class('gda_rook_weights__SWIG_2'))

# Start of gda_rook_weights

`gda_rook_weights__SWIG_3` = function(geoda)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  ;ans = .Call('R_swig_gda_rook_weights__SWIG_3', geoda, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_rook_weights__SWIG_3`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_rook_weights__SWIG_3`, "inputTypes") = c('_p_AbstractGeoDa')
class(`gda_rook_weights__SWIG_3`) = c("SWIGFunction", class('gda_rook_weights__SWIG_3'))

`gda_rook_weights` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]]))) {
      f <- gda_rook_weights__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- gda_rook_weights__SWIG_2; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- gda_rook_weights__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- gda_rook_weights__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_rook_weights with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_knn_weights

`gda_knn_weights__SWIG_0` = function(geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth, adaptive_bandwidth, use_kernel_diagnals, polyid)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  kernel = as(kernel, "character"); 
  
  adaptive_bandwidth = as.logical(adaptive_bandwidth);
  use_kernel_diagnals = as.logical(use_kernel_diagnals);
  polyid = as(polyid, "character"); 
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_0', geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth, adaptive_bandwidth, use_kernel_diagnals, polyid, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_0`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_0`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical', 'logical', 'logical', 'character', 'numeric', 'logical', 'logical', 'character')
class(`gda_knn_weights__SWIG_0`) = c("SWIGFunction", class('gda_knn_weights__SWIG_0'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_1` = function(geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth, adaptive_bandwidth, use_kernel_diagnals)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  kernel = as(kernel, "character"); 
  
  adaptive_bandwidth = as.logical(adaptive_bandwidth);
  use_kernel_diagnals = as.logical(use_kernel_diagnals);
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_1', geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth, adaptive_bandwidth, use_kernel_diagnals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_1`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_1`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical', 'logical', 'logical', 'character', 'numeric', 'logical', 'logical')
class(`gda_knn_weights__SWIG_1`) = c("SWIGFunction", class('gda_knn_weights__SWIG_1'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_2` = function(geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth, adaptive_bandwidth)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  kernel = as(kernel, "character"); 
  
  adaptive_bandwidth = as.logical(adaptive_bandwidth);
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_2', geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth, adaptive_bandwidth, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_2`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_2`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical', 'logical', 'logical', 'character', 'numeric', 'logical')
class(`gda_knn_weights__SWIG_2`) = c("SWIGFunction", class('gda_knn_weights__SWIG_2'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_3` = function(geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  kernel = as(kernel, "character"); 
  
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_3', geoda, k, power, is_inverse, is_arc, is_mile, kernel, bandwidth, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_3`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_3`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical', 'logical', 'logical', 'character', 'numeric')
class(`gda_knn_weights__SWIG_3`) = c("SWIGFunction", class('gda_knn_weights__SWIG_3'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_4` = function(geoda, k, power, is_inverse, is_arc, is_mile, kernel)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  kernel = as(kernel, "character"); 
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_4', geoda, k, power, is_inverse, is_arc, is_mile, kernel, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_4`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_4`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical', 'logical', 'logical', 'character')
class(`gda_knn_weights__SWIG_4`) = c("SWIGFunction", class('gda_knn_weights__SWIG_4'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_5` = function(geoda, k, power, is_inverse, is_arc, is_mile)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_5', geoda, k, power, is_inverse, is_arc, is_mile, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_5`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_5`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical', 'logical', 'logical')
class(`gda_knn_weights__SWIG_5`) = c("SWIGFunction", class('gda_knn_weights__SWIG_5'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_6` = function(geoda, k, power, is_inverse, is_arc)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_6', geoda, k, power, is_inverse, is_arc, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_6`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_6`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical', 'logical')
class(`gda_knn_weights__SWIG_6`) = c("SWIGFunction", class('gda_knn_weights__SWIG_6'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_7` = function(geoda, k, power, is_inverse)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  is_inverse = as.logical(is_inverse);
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_7', geoda, k, power, is_inverse, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_7`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_7`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric', 'logical')
class(`gda_knn_weights__SWIG_7`) = c("SWIGFunction", class('gda_knn_weights__SWIG_7'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_8` = function(geoda, k, power)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_8', geoda, k, power, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_8`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_8`, "inputTypes") = c('_p_AbstractGeoDa', 'integer', 'numeric')
class(`gda_knn_weights__SWIG_8`) = c("SWIGFunction", class('gda_knn_weights__SWIG_8'))

# Start of gda_knn_weights

`gda_knn_weights__SWIG_9` = function(geoda, k)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  ;ans = .Call('R_swig_gda_knn_weights__SWIG_9', geoda, k, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_knn_weights__SWIG_9`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_knn_weights__SWIG_9`, "inputTypes") = c('_p_AbstractGeoDa', 'integer')
class(`gda_knn_weights__SWIG_9`) = c("SWIGFunction", class('gda_knn_weights__SWIG_9'))

`gda_knn_weights` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 10
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- gda_knn_weights__SWIG_9; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- gda_knn_weights__SWIG_8; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- gda_knn_weights__SWIG_7; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- gda_knn_weights__SWIG_6; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- gda_knn_weights__SWIG_5; 
    }
  } else if (argc == 7) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && is.character(argv[[7]]) && length(argv[[7]]) == 1) {
      f <- gda_knn_weights__SWIG_4; 
    }
  } else if (argc == 8) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && is.character(argv[[7]]) && length(argv[[7]]) == 1 && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 )) {
      f <- gda_knn_weights__SWIG_3; 
    }
  } else if (argc == 9) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && is.character(argv[[7]]) && length(argv[[7]]) == 1 && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 ) && ( is.logical(argv[[9]]) && length(argv[[9]]) == 1 )) {
      f <- gda_knn_weights__SWIG_2; 
    }
  } else if (argc == 10) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && is.character(argv[[7]]) && length(argv[[7]]) == 1 && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 ) && ( is.logical(argv[[9]]) && length(argv[[9]]) == 1 ) && ( is.logical(argv[[10]]) && length(argv[[10]]) == 1 )) {
      f <- gda_knn_weights__SWIG_1; 
    }
  } else if (argc == 11) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && is.character(argv[[7]]) && length(argv[[7]]) == 1 && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 ) && ( is.logical(argv[[9]]) && length(argv[[9]]) == 1 ) && ( is.logical(argv[[10]]) && length(argv[[10]]) == 1 ) && is.character(argv[[11]]) && length(argv[[11]]) == 1) {
      f <- gda_knn_weights__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_knn_weights with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_min_distthreshold

`gda_min_distthreshold__SWIG_0` = function(geoda, is_arc, is_mile, .copy = FALSE)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  ;.Call('R_swig_gda_min_distthreshold__SWIG_0', geoda, is_arc, is_mile, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_min_distthreshold__SWIG_0`, 'returnType') = 'numeric'
attr(`gda_min_distthreshold__SWIG_0`, "inputTypes") = c('_p_AbstractGeoDa', 'logical', 'logical')
class(`gda_min_distthreshold__SWIG_0`) = c("SWIGFunction", class('gda_min_distthreshold__SWIG_0'))

# Start of gda_min_distthreshold

`gda_min_distthreshold__SWIG_1` = function(geoda, is_arc, .copy = FALSE)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  is_arc = as.logical(is_arc);
  ;.Call('R_swig_gda_min_distthreshold__SWIG_1', geoda, is_arc, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_min_distthreshold__SWIG_1`, 'returnType') = 'numeric'
attr(`gda_min_distthreshold__SWIG_1`, "inputTypes") = c('_p_AbstractGeoDa', 'logical')
class(`gda_min_distthreshold__SWIG_1`) = c("SWIGFunction", class('gda_min_distthreshold__SWIG_1'))

# Start of gda_min_distthreshold

`gda_min_distthreshold__SWIG_2` = function(geoda, .copy = FALSE)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  ;.Call('R_swig_gda_min_distthreshold__SWIG_2', geoda, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_min_distthreshold__SWIG_2`, 'returnType') = 'numeric'
attr(`gda_min_distthreshold__SWIG_2`, "inputTypes") = c('_p_AbstractGeoDa')
class(`gda_min_distthreshold__SWIG_2`) = c("SWIGFunction", class('gda_min_distthreshold__SWIG_2'))

`gda_min_distthreshold` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]]))) {
      f <- gda_min_distthreshold__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- gda_min_distthreshold__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- gda_min_distthreshold__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_min_distthreshold with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_distance_weights

`gda_distance_weights__SWIG_0` = function(geoda, dist_thres, polyid, power, is_inverse, is_arc, is_mile, kernel, use_kernel_diagonals)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  polyid = as(polyid, "character"); 
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  kernel = as(kernel, "character"); 
  use_kernel_diagonals = as.logical(use_kernel_diagonals);
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_0', geoda, dist_thres, polyid, power, is_inverse, is_arc, is_mile, kernel, use_kernel_diagonals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_0`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_0`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric', 'character', 'numeric', 'logical', 'logical', 'logical', 'character', 'logical')
class(`gda_distance_weights__SWIG_0`) = c("SWIGFunction", class('gda_distance_weights__SWIG_0'))

# Start of gda_distance_weights

`gda_distance_weights__SWIG_1` = function(geoda, dist_thres, polyid, power, is_inverse, is_arc, is_mile, kernel)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  polyid = as(polyid, "character"); 
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  kernel = as(kernel, "character"); 
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_1', geoda, dist_thres, polyid, power, is_inverse, is_arc, is_mile, kernel, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_1`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_1`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric', 'character', 'numeric', 'logical', 'logical', 'logical', 'character')
class(`gda_distance_weights__SWIG_1`) = c("SWIGFunction", class('gda_distance_weights__SWIG_1'))

# Start of gda_distance_weights

`gda_distance_weights__SWIG_2` = function(geoda, dist_thres, polyid, power, is_inverse, is_arc, is_mile)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  polyid = as(polyid, "character"); 
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  is_mile = as.logical(is_mile);
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_2', geoda, dist_thres, polyid, power, is_inverse, is_arc, is_mile, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_2`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_2`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric', 'character', 'numeric', 'logical', 'logical', 'logical')
class(`gda_distance_weights__SWIG_2`) = c("SWIGFunction", class('gda_distance_weights__SWIG_2'))

# Start of gda_distance_weights

`gda_distance_weights__SWIG_3` = function(geoda, dist_thres, polyid, power, is_inverse, is_arc)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  polyid = as(polyid, "character"); 
  
  is_inverse = as.logical(is_inverse);
  is_arc = as.logical(is_arc);
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_3', geoda, dist_thres, polyid, power, is_inverse, is_arc, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_3`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_3`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric', 'character', 'numeric', 'logical', 'logical')
class(`gda_distance_weights__SWIG_3`) = c("SWIGFunction", class('gda_distance_weights__SWIG_3'))

# Start of gda_distance_weights

`gda_distance_weights__SWIG_4` = function(geoda, dist_thres, polyid, power, is_inverse)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  polyid = as(polyid, "character"); 
  
  is_inverse = as.logical(is_inverse);
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_4', geoda, dist_thres, polyid, power, is_inverse, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_4`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_4`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric', 'character', 'numeric', 'logical')
class(`gda_distance_weights__SWIG_4`) = c("SWIGFunction", class('gda_distance_weights__SWIG_4'))

# Start of gda_distance_weights

`gda_distance_weights__SWIG_5` = function(geoda, dist_thres, polyid, power)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  polyid = as(polyid, "character"); 
  
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_5', geoda, dist_thres, polyid, power, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_5`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_5`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric', 'character', 'numeric')
class(`gda_distance_weights__SWIG_5`) = c("SWIGFunction", class('gda_distance_weights__SWIG_5'))

# Start of gda_distance_weights

`gda_distance_weights__SWIG_6` = function(geoda, dist_thres, polyid)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  polyid = as(polyid, "character"); 
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_6', geoda, dist_thres, polyid, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_6`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_6`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric', 'character')
class(`gda_distance_weights__SWIG_6`) = c("SWIGFunction", class('gda_distance_weights__SWIG_6'))

# Start of gda_distance_weights

`gda_distance_weights__SWIG_7` = function(geoda, dist_thres)
{
  if (inherits(geoda, "ExternalReference")) geoda = slot(geoda,"ref") 
  
  ;ans = .Call('R_swig_gda_distance_weights__SWIG_7', geoda, dist_thres, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`gda_distance_weights__SWIG_7`, 'returnType') = '_p_GeoDaWeight'
attr(`gda_distance_weights__SWIG_7`, "inputTypes") = c('_p_AbstractGeoDa', 'numeric')
class(`gda_distance_weights__SWIG_7`) = c("SWIGFunction", class('gda_distance_weights__SWIG_7'))

`gda_distance_weights` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- gda_distance_weights__SWIG_7; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- gda_distance_weights__SWIG_6; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- gda_distance_weights__SWIG_5; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- gda_distance_weights__SWIG_4; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- gda_distance_weights__SWIG_3; 
    }
  } else if (argc == 7) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && ( is.logical(argv[[7]]) && length(argv[[7]]) == 1 )) {
      f <- gda_distance_weights__SWIG_2; 
    }
  } else if (argc == 8) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && ( is.logical(argv[[7]]) && length(argv[[7]]) == 1 ) && is.character(argv[[8]]) && length(argv[[8]]) == 1) {
      f <- gda_distance_weights__SWIG_1; 
    }
  } else if (argc == 9) {
    if ((extends(argtypes[1], '_p_AbstractGeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.logical(argv[[6]]) && length(argv[[6]]) == 1 ) && ( is.logical(argv[[7]]) && length(argv[[7]]) == 1 ) && is.character(argv[[8]]) && length(argv[[8]]) == 1 && ( is.logical(argv[[9]]) && length(argv[[9]]) == 1 )) {
      f <- gda_distance_weights__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_distance_weights with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_maxp

`gda_maxp__SWIG_0` = function(w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, seeds, distance_method, rand_seed, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  local_search_method = as(local_search_method, "character"); 
  initial = as.integer(initial);
  
  if(length(initial) > 1) {
    warning("using only the first element of initial");
  };
  
  tabu_length = as.integer(tabu_length);
  
  if(length(tabu_length) > 1) {
    warning("using only the first element of tabu_length");
  };
  
  
  seeds = as.integer(seeds);
  distance_method = as(distance_method, "character"); 
  rand_seed = as.integer(rand_seed);
  
  if(length(rand_seed) > 1) {
    warning("using only the first element of rand_seed");
  };
  
  ;.Call('R_swig_gda_maxp__SWIG_0', w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, seeds, distance_method, rand_seed, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_0`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'character', 'integer', 'integer', 'numeric', '_p_std__vectorT_int_std__allocatorT_int_t_t', 'character', 'integer')
class(`gda_maxp__SWIG_0`) = c("SWIGFunction", class('gda_maxp__SWIG_0'))

# Start of gda_maxp

`gda_maxp__SWIG_1` = function(w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, seeds, distance_method, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  local_search_method = as(local_search_method, "character"); 
  initial = as.integer(initial);
  
  if(length(initial) > 1) {
    warning("using only the first element of initial");
  };
  
  tabu_length = as.integer(tabu_length);
  
  if(length(tabu_length) > 1) {
    warning("using only the first element of tabu_length");
  };
  
  
  seeds = as.integer(seeds);
  distance_method = as(distance_method, "character"); 
  ;.Call('R_swig_gda_maxp__SWIG_1', w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, seeds, distance_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_1`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'character', 'integer', 'integer', 'numeric', '_p_std__vectorT_int_std__allocatorT_int_t_t', 'character')
class(`gda_maxp__SWIG_1`) = c("SWIGFunction", class('gda_maxp__SWIG_1'))

# Start of gda_maxp

`gda_maxp__SWIG_2` = function(w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, seeds, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  local_search_method = as(local_search_method, "character"); 
  initial = as.integer(initial);
  
  if(length(initial) > 1) {
    warning("using only the first element of initial");
  };
  
  tabu_length = as.integer(tabu_length);
  
  if(length(tabu_length) > 1) {
    warning("using only the first element of tabu_length");
  };
  
  
  seeds = as.integer(seeds);
  ;.Call('R_swig_gda_maxp__SWIG_2', w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, seeds, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_2`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_2`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'character', 'integer', 'integer', 'numeric', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`gda_maxp__SWIG_2`) = c("SWIGFunction", class('gda_maxp__SWIG_2'))

# Start of gda_maxp

`gda_maxp__SWIG_3` = function(w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  local_search_method = as(local_search_method, "character"); 
  initial = as.integer(initial);
  
  if(length(initial) > 1) {
    warning("using only the first element of initial");
  };
  
  tabu_length = as.integer(tabu_length);
  
  if(length(tabu_length) > 1) {
    warning("using only the first element of tabu_length");
  };
  
  
  ;.Call('R_swig_gda_maxp__SWIG_3', w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, cool_rate, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_3`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_3`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'character', 'integer', 'integer', 'numeric')
class(`gda_maxp__SWIG_3`) = c("SWIGFunction", class('gda_maxp__SWIG_3'))

# Start of gda_maxp

`gda_maxp__SWIG_4` = function(w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  local_search_method = as(local_search_method, "character"); 
  initial = as.integer(initial);
  
  if(length(initial) > 1) {
    warning("using only the first element of initial");
  };
  
  tabu_length = as.integer(tabu_length);
  
  if(length(tabu_length) > 1) {
    warning("using only the first element of tabu_length");
  };
  
  ;.Call('R_swig_gda_maxp__SWIG_4', w, data, bound_vals, min_bound, local_search_method, initial, tabu_length, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_4`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_4`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'character', 'integer', 'integer')
class(`gda_maxp__SWIG_4`) = c("SWIGFunction", class('gda_maxp__SWIG_4'))

# Start of gda_maxp

`gda_maxp__SWIG_5` = function(w, data, bound_vals, min_bound, local_search_method, initial, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  local_search_method = as(local_search_method, "character"); 
  initial = as.integer(initial);
  
  if(length(initial) > 1) {
    warning("using only the first element of initial");
  };
  
  ;.Call('R_swig_gda_maxp__SWIG_5', w, data, bound_vals, min_bound, local_search_method, initial, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_5`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_5`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'character', 'integer')
class(`gda_maxp__SWIG_5`) = c("SWIGFunction", class('gda_maxp__SWIG_5'))

# Start of gda_maxp

`gda_maxp__SWIG_6` = function(w, data, bound_vals, min_bound, local_search_method, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  local_search_method = as(local_search_method, "character"); 
  ;.Call('R_swig_gda_maxp__SWIG_6', w, data, bound_vals, min_bound, local_search_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_6`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_6`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'character')
class(`gda_maxp__SWIG_6`) = c("SWIGFunction", class('gda_maxp__SWIG_6'))

# Start of gda_maxp

`gda_maxp__SWIG_7` = function(w, data, bound_vals, min_bound, .copy = FALSE)
{
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  bound_vals = as.numeric(bound_vals);
  
  ;.Call('R_swig_gda_maxp__SWIG_7', w, data, bound_vals, min_bound, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_maxp__SWIG_7`, 'returnType') = 'list'
attr(`gda_maxp__SWIG_7`, "inputTypes") = c('_p_GeoDaWeight', 'list', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`gda_maxp__SWIG_7`) = c("SWIGFunction", class('gda_maxp__SWIG_7'))

`gda_maxp` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- gda_maxp__SWIG_7; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1) {
      f <- gda_maxp__SWIG_6; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- gda_maxp__SWIG_5; 
    }
  } else if (argc == 7) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 )) {
      f <- gda_maxp__SWIG_4; 
    }
  } else if (argc == 8) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 ) && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 )) {
      f <- gda_maxp__SWIG_3; 
    }
  } else if (argc == 9) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 ) && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 ) && ( is.integer(argv[[9]]) || is.numeric(argv[[9]]) )) {
      f <- gda_maxp__SWIG_2; 
    }
  } else if (argc == 10) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 ) && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 ) && ( is.integer(argv[[9]]) || is.numeric(argv[[9]]) ) && is.character(argv[[10]]) && length(argv[[10]]) == 1) {
      f <- gda_maxp__SWIG_1; 
    }
  } else if (argc == 11) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.numeric(argv[[3]]) ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 ) && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 ) && ( is.integer(argv[[9]]) || is.numeric(argv[[9]]) ) && is.character(argv[[10]]) && length(argv[[10]]) == 1 && ( (is.integer(argv[[11]]) || is.numeric(argv[[11]])) && length(argv[[11]]) == 1 )) {
      f <- gda_maxp__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_maxp with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_redcap

`gda_redcap__SWIG_0` = function(k, w, data, redcap_method, distance_method, bound_vals, min_bound, rand_seed, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  redcap_method = as(redcap_method, "character"); 
  distance_method = as(distance_method, "character"); 
  bound_vals = as.numeric(bound_vals);
  
  rand_seed = as.integer(rand_seed);
  
  if(length(rand_seed) > 1) {
    warning("using only the first element of rand_seed");
  };
  
  ;.Call('R_swig_gda_redcap__SWIG_0', k, w, data, redcap_method, distance_method, bound_vals, min_bound, rand_seed, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_redcap__SWIG_0`, 'returnType') = 'list'
attr(`gda_redcap__SWIG_0`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'integer')
class(`gda_redcap__SWIG_0`) = c("SWIGFunction", class('gda_redcap__SWIG_0'))

# Start of gda_redcap

`gda_redcap__SWIG_1` = function(k, w, data, redcap_method, distance_method, bound_vals, min_bound, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  redcap_method = as(redcap_method, "character"); 
  distance_method = as(distance_method, "character"); 
  bound_vals = as.numeric(bound_vals);
  
  ;.Call('R_swig_gda_redcap__SWIG_1', k, w, data, redcap_method, distance_method, bound_vals, min_bound, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_redcap__SWIG_1`, 'returnType') = 'list'
attr(`gda_redcap__SWIG_1`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`gda_redcap__SWIG_1`) = c("SWIGFunction", class('gda_redcap__SWIG_1'))

# Start of gda_redcap

`gda_redcap__SWIG_2` = function(k, w, data, redcap_method, distance_method, bound_vals, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  redcap_method = as(redcap_method, "character"); 
  distance_method = as(distance_method, "character"); 
  bound_vals = as.numeric(bound_vals);
  ;.Call('R_swig_gda_redcap__SWIG_2', k, w, data, redcap_method, distance_method, bound_vals, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_redcap__SWIG_2`, 'returnType') = 'list'
attr(`gda_redcap__SWIG_2`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_redcap__SWIG_2`) = c("SWIGFunction", class('gda_redcap__SWIG_2'))

# Start of gda_redcap

`gda_redcap__SWIG_3` = function(k, w, data, redcap_method, distance_method, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  redcap_method = as(redcap_method, "character"); 
  distance_method = as(distance_method, "character"); 
  ;.Call('R_swig_gda_redcap__SWIG_3', k, w, data, redcap_method, distance_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_redcap__SWIG_3`, 'returnType') = 'list'
attr(`gda_redcap__SWIG_3`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character', 'character')
class(`gda_redcap__SWIG_3`) = c("SWIGFunction", class('gda_redcap__SWIG_3'))

# Start of gda_redcap

`gda_redcap__SWIG_4` = function(k, w, data, redcap_method, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  redcap_method = as(redcap_method, "character"); 
  ;.Call('R_swig_gda_redcap__SWIG_4', k, w, data, redcap_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_redcap__SWIG_4`, 'returnType') = 'list'
attr(`gda_redcap__SWIG_4`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character')
class(`gda_redcap__SWIG_4`) = c("SWIGFunction", class('gda_redcap__SWIG_4'))

# Start of gda_redcap

`gda_redcap__SWIG_5` = function(k, w, data, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  ;.Call('R_swig_gda_redcap__SWIG_5', k, w, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_redcap__SWIG_5`, 'returnType') = 'list'
attr(`gda_redcap__SWIG_5`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list')
class(`gda_redcap__SWIG_5`) = c("SWIGFunction", class('gda_redcap__SWIG_5'))

`gda_redcap` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) )) {
      f <- gda_redcap__SWIG_5; 
    }
  } else if (argc == 4) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- gda_redcap__SWIG_4; 
    }
  } else if (argc == 5) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && is.character(argv[[5]]) && length(argv[[5]]) == 1) {
      f <- gda_redcap__SWIG_3; 
    }
  } else if (argc == 6) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( is.numeric(argv[[6]]) )) {
      f <- gda_redcap__SWIG_2; 
    }
  } else if (argc == 7) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 )) {
      f <- gda_redcap__SWIG_1; 
    }
  } else if (argc == 8) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( is.numeric(argv[[6]]) ) && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 ) && ( (is.integer(argv[[8]]) || is.numeric(argv[[8]])) && length(argv[[8]]) == 1 )) {
      f <- gda_redcap__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_redcap with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_skater

`gda_skater__SWIG_0` = function(k, w, data, distance_method, bound_vals, min_bound, rand_seed, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  bound_vals = as.numeric(bound_vals);
  
  rand_seed = as.integer(rand_seed);
  
  if(length(rand_seed) > 1) {
    warning("using only the first element of rand_seed");
  };
  
  ;.Call('R_swig_gda_skater__SWIG_0', k, w, data, distance_method, bound_vals, min_bound, rand_seed, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_skater__SWIG_0`, 'returnType') = 'list'
attr(`gda_skater__SWIG_0`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric', 'integer')
class(`gda_skater__SWIG_0`) = c("SWIGFunction", class('gda_skater__SWIG_0'))

# Start of gda_skater

`gda_skater__SWIG_1` = function(k, w, data, distance_method, bound_vals, min_bound, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  bound_vals = as.numeric(bound_vals);
  
  ;.Call('R_swig_gda_skater__SWIG_1', k, w, data, distance_method, bound_vals, min_bound, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_skater__SWIG_1`, 'returnType') = 'list'
attr(`gda_skater__SWIG_1`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`gda_skater__SWIG_1`) = c("SWIGFunction", class('gda_skater__SWIG_1'))

# Start of gda_skater

`gda_skater__SWIG_2` = function(k, w, data, distance_method, bound_vals, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  bound_vals = as.numeric(bound_vals);
  ;.Call('R_swig_gda_skater__SWIG_2', k, w, data, distance_method, bound_vals, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_skater__SWIG_2`, 'returnType') = 'list'
attr(`gda_skater__SWIG_2`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_skater__SWIG_2`) = c("SWIGFunction", class('gda_skater__SWIG_2'))

# Start of gda_skater

`gda_skater__SWIG_3` = function(k, w, data, distance_method, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  ;.Call('R_swig_gda_skater__SWIG_3', k, w, data, distance_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_skater__SWIG_3`, 'returnType') = 'list'
attr(`gda_skater__SWIG_3`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list', 'character')
class(`gda_skater__SWIG_3`) = c("SWIGFunction", class('gda_skater__SWIG_3'))

# Start of gda_skater

`gda_skater__SWIG_4` = function(k, w, data, .copy = FALSE)
{
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  ;.Call('R_swig_gda_skater__SWIG_4', k, w, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_skater__SWIG_4`, 'returnType') = 'list'
attr(`gda_skater__SWIG_4`, "inputTypes") = c('integer', '_p_GeoDaWeight', 'list')
class(`gda_skater__SWIG_4`) = c("SWIGFunction", class('gda_skater__SWIG_4'))

`gda_skater` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) )) {
      f <- gda_skater__SWIG_4; 
    }
  } else if (argc == 4) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- gda_skater__SWIG_3; 
    }
  } else if (argc == 5) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && ( is.numeric(argv[[5]]) )) {
      f <- gda_skater__SWIG_2; 
    }
  } else if (argc == 6) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && ( is.numeric(argv[[5]]) ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- gda_skater__SWIG_1; 
    }
  } else if (argc == 7) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.list(argv[[3]]) && all(sapply(argv[[3]] , is.integer) || sapply(argv[[3]], is.numeric)) ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && ( is.numeric(argv[[5]]) ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 )) {
      f <- gda_skater__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_skater with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_sumofsquares

`gda_sumofsquares` = function(vals, .copy = FALSE)
{
  vals = as.numeric(vals);
  ;.Call('R_swig_gda_sumofsquares', vals, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_sumofsquares`, 'returnType') = 'numeric'
attr(`gda_sumofsquares`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`gda_sumofsquares`) = c("SWIGFunction", class('gda_sumofsquares'))

# Start of gda_totalsumofsquare

`gda_totalsumofsquare` = function(vals, .copy = FALSE)
{
  vals = lapply(vals, as.numeric);
  ;.Call('R_swig_gda_totalsumofsquare', vals, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_totalsumofsquare`, 'returnType') = 'numeric'
attr(`gda_totalsumofsquare`, "inputTypes") = c('list')
class(`gda_totalsumofsquare`) = c("SWIGFunction", class('gda_totalsumofsquare'))

# Start of gda_withinsumofsquare

`gda_withinsumofsquare` = function(solution, vals, .copy = FALSE)
{
  solution = lapply(solution, as.integer);
  vals = lapply(vals, as.numeric);
  ;.Call('R_swig_gda_withinsumofsquare', solution, vals, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_withinsumofsquare`, 'returnType') = 'numeric'
attr(`gda_withinsumofsquare`, "inputTypes") = c('list', 'list')
class(`gda_withinsumofsquare`) = c("SWIGFunction", class('gda_withinsumofsquare'))

# Start of gda_betweensumofsquare

`gda_betweensumofsquare` = function(solution, data, .copy = FALSE)
{
  solution = lapply(solution, as.integer);
  data = lapply(data, as.numeric);
  ;.Call('R_swig_gda_betweensumofsquare', solution, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_betweensumofsquare`, 'returnType') = 'numeric'
attr(`gda_betweensumofsquare`, "inputTypes") = c('list', 'list')
class(`gda_betweensumofsquare`) = c("SWIGFunction", class('gda_betweensumofsquare'))

# Start of new_PCAResult

`PCAResult` = function(method)
{
  method = as(method, "character"); 
  ;ans = .Call('R_swig_new_PCAResult', method, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_PCAResult", ref=ans);
  
  reg.finalizer(ans@ref, delete_PCAResult)
  ans
  
}

attr(`PCAResult`, 'returnType') = '_p_PCAResult'
attr(`PCAResult`, "inputTypes") = c('character')
class(`PCAResult`) = c("SWIGFunction", class('PCAResult'))

# Start of delete_PCAResult

`delete_PCAResult` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_PCAResult', self, PACKAGE='rgeoda');
  
}

attr(`delete_PCAResult`, 'returnType') = 'void'
attr(`delete_PCAResult`, "inputTypes") = c('_p_PCAResult')
class(`delete_PCAResult`) = c("SWIGFunction", class('delete_PCAResult'))

# Start of PCAResult_setMethod

`PCAResult_setMethod` = function(self, method)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  method = as(method, "character"); 
  ;.Call('R_swig_PCAResult_setMethod', self, method, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setMethod`, 'returnType') = 'void'
attr(`PCAResult_setMethod`, "inputTypes") = c('_p_PCAResult', 'character')
class(`PCAResult_setMethod`) = c("SWIGFunction", class('PCAResult_setMethod'))

# Start of PCAResult_setStandardDev

`PCAResult_setStandardDev` = function(self, standardDev)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  standardDev = as.numeric(standardDev);
  ;.Call('R_swig_PCAResult_setStandardDev', self, standardDev, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setStandardDev`, 'returnType') = 'void'
attr(`PCAResult_setStandardDev`, "inputTypes") = c('_p_PCAResult', 'numeric')
class(`PCAResult_setStandardDev`) = c("SWIGFunction", class('PCAResult_setStandardDev'))

# Start of PCAResult_setPropOfVar

`PCAResult_setPropOfVar` = function(self, propOfVar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  propOfVar = as.numeric(propOfVar);
  ;.Call('R_swig_PCAResult_setPropOfVar', self, propOfVar, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setPropOfVar`, 'returnType') = 'void'
attr(`PCAResult_setPropOfVar`, "inputTypes") = c('_p_PCAResult', 'numeric')
class(`PCAResult_setPropOfVar`) = c("SWIGFunction", class('PCAResult_setPropOfVar'))

# Start of PCAResult_setCumProp

`PCAResult_setCumProp` = function(self, cumProp)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  cumProp = as.numeric(cumProp);
  ;.Call('R_swig_PCAResult_setCumProp', self, cumProp, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setCumProp`, 'returnType') = 'void'
attr(`PCAResult_setCumProp`, "inputTypes") = c('_p_PCAResult', 'numeric')
class(`PCAResult_setCumProp`) = c("SWIGFunction", class('PCAResult_setCumProp'))

# Start of PCAResult_setThresh95

`PCAResult_setThresh95` = function(self, thresh95)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_PCAResult_setThresh95', self, thresh95, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setThresh95`, 'returnType') = 'void'
attr(`PCAResult_setThresh95`, "inputTypes") = c('_p_PCAResult', 'numeric')
class(`PCAResult_setThresh95`) = c("SWIGFunction", class('PCAResult_setThresh95'))

# Start of PCAResult_setEigenValues

`PCAResult_setEigenValues` = function(self, eigenValues)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  eigenValues = as.numeric(eigenValues);
  ;.Call('R_swig_PCAResult_setEigenValues', self, eigenValues, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setEigenValues`, 'returnType') = 'void'
attr(`PCAResult_setEigenValues`, "inputTypes") = c('_p_PCAResult', 'numeric')
class(`PCAResult_setEigenValues`) = c("SWIGFunction", class('PCAResult_setEigenValues'))

# Start of PCAResult_setScores

`PCAResult_setScores` = function(self, scores)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  scores = as.numeric(scores);
  ;.Call('R_swig_PCAResult_setScores', self, scores, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setScores`, 'returnType') = 'void'
attr(`PCAResult_setScores`, "inputTypes") = c('_p_PCAResult', 'numeric')
class(`PCAResult_setScores`) = c("SWIGFunction", class('PCAResult_setScores'))

# Start of PCAResult_setLoadings

`PCAResult_setLoadings` = function(self, loadings)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  loadings = lapply(loadings, as.numeric);
  ;.Call('R_swig_PCAResult_setLoadings', self, loadings, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setLoadings`, 'returnType') = 'void'
attr(`PCAResult_setLoadings`, "inputTypes") = c('_p_PCAResult', '_p_std__vectorT_std__vectorT_float_std__allocatorT_float_t_t_std__allocatorT_std__vectorT_float_std__allocatorT_float_t_t_t_t')
class(`PCAResult_setLoadings`) = c("SWIGFunction", class('PCAResult_setLoadings'))

# Start of PCAResult_setSqCorrelations

`PCAResult_setSqCorrelations` = function(self, sqCorrelations)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  sqCorrelations = lapply(sqCorrelations, as.numeric);
  ;.Call('R_swig_PCAResult_setSqCorrelations', self, sqCorrelations, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setSqCorrelations`, 'returnType') = 'void'
attr(`PCAResult_setSqCorrelations`, "inputTypes") = c('_p_PCAResult', '_p_std__vectorT_std__vectorT_float_std__allocatorT_float_t_t_std__allocatorT_std__vectorT_float_std__allocatorT_float_t_t_t_t')
class(`PCAResult_setSqCorrelations`) = c("SWIGFunction", class('PCAResult_setSqCorrelations'))

# Start of PCAResult_setPriComponents

`PCAResult_setPriComponents` = function(self, priComponents)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  priComponents = lapply(priComponents, as.numeric);
  ;.Call('R_swig_PCAResult_setPriComponents', self, priComponents, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setPriComponents`, 'returnType') = 'void'
attr(`PCAResult_setPriComponents`, "inputTypes") = c('_p_PCAResult', '_p_std__vectorT_std__vectorT_float_std__allocatorT_float_t_t_std__allocatorT_std__vectorT_float_std__allocatorT_float_t_t_t_t')
class(`PCAResult_setPriComponents`) = c("SWIGFunction", class('PCAResult_setPriComponents'))

# Start of PCAResult_getMethod

`PCAResult_getMethod` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getMethod', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getMethod`, 'returnType') = 'character'
attr(`PCAResult_getMethod`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getMethod`) = c("SWIGFunction", class('PCAResult_getMethod'))

# Start of PCAResult_getStandardDev

`PCAResult_getStandardDev` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getStandardDev', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getStandardDev`, 'returnType') = 'numeric'
attr(`PCAResult_getStandardDev`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getStandardDev`) = c("SWIGFunction", class('PCAResult_getStandardDev'))

# Start of PCAResult_getPropOfVar

`PCAResult_getPropOfVar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getPropOfVar', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getPropOfVar`, 'returnType') = 'numeric'
attr(`PCAResult_getPropOfVar`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getPropOfVar`) = c("SWIGFunction", class('PCAResult_getPropOfVar'))

# Start of PCAResult_getCumProp

`PCAResult_getCumProp` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getCumProp', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getCumProp`, 'returnType') = 'numeric'
attr(`PCAResult_getCumProp`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getCumProp`) = c("SWIGFunction", class('PCAResult_getCumProp'))

# Start of PCAResult_getThresh95

`PCAResult_getThresh95` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getThresh95', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getThresh95`, 'returnType') = 'numeric'
attr(`PCAResult_getThresh95`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getThresh95`) = c("SWIGFunction", class('PCAResult_getThresh95'))

# Start of PCAResult_getEigenValues

`PCAResult_getEigenValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getEigenValues', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getEigenValues`, 'returnType') = 'numeric'
attr(`PCAResult_getEigenValues`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getEigenValues`) = c("SWIGFunction", class('PCAResult_getEigenValues'))

# Start of PCAResult_getLoadings

`PCAResult_getLoadings` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getLoadings', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getLoadings`, 'returnType') = 'list'
attr(`PCAResult_getLoadings`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getLoadings`) = c("SWIGFunction", class('PCAResult_getLoadings'))

# Start of PCAResult_getSqCorrelations

`PCAResult_getSqCorrelations` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getSqCorrelations', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getSqCorrelations`, 'returnType') = 'list'
attr(`PCAResult_getSqCorrelations`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getSqCorrelations`) = c("SWIGFunction", class('PCAResult_getSqCorrelations'))

# Start of PCAResult_getPriComponents

`PCAResult_getPriComponents` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getPriComponents', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getPriComponents`, 'returnType') = 'list'
attr(`PCAResult_getPriComponents`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getPriComponents`) = c("SWIGFunction", class('PCAResult_getPriComponents'))

# Start of PCAResult_getKComponents

`PCAResult_getKComponents` = function(self, k, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  ;.Call('R_swig_PCAResult_getKComponents', self, k, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getKComponents`, 'returnType') = 'list'
attr(`PCAResult_getKComponents`, "inputTypes") = c('_p_PCAResult', 'integer')
class(`PCAResult_getKComponents`) = c("SWIGFunction", class('PCAResult_getKComponents'))

# Start of PCAResult_setKaiser

`PCAResult_setKaiser` = function(self, kaiser)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_PCAResult_setKaiser', self, kaiser, PACKAGE='rgeoda');
  
}

attr(`PCAResult_setKaiser`, 'returnType') = 'void'
attr(`PCAResult_setKaiser`, "inputTypes") = c('_p_PCAResult', 'numeric')
class(`PCAResult_setKaiser`) = c("SWIGFunction", class('PCAResult_setKaiser'))

# Start of PCAResult_getKaiser

`PCAResult_getKaiser` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_getKaiser', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_getKaiser`, 'returnType') = 'numeric'
attr(`PCAResult_getKaiser`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_getKaiser`) = c("SWIGFunction", class('PCAResult_getKaiser'))

# Start of PCAResult_row_lim_set

`PCAResult_row_lim_set` = function(self, s_row_lim)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_row_lim = as.integer(s_row_lim);
  
  if(length(s_row_lim) > 1) {
    warning("using only the first element of s_row_lim");
  };
  
  ;.Call('R_swig_PCAResult_row_lim_set', self, s_row_lim, PACKAGE='rgeoda');
  
}

attr(`PCAResult_row_lim_set`, 'returnType') = 'void'
attr(`PCAResult_row_lim_set`, "inputTypes") = c('_p_PCAResult', 'integer')
class(`PCAResult_row_lim_set`) = c("SWIGFunction", class('PCAResult_row_lim_set'))

# Start of PCAResult_row_lim_get

`PCAResult_row_lim_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_row_lim_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_row_lim_get`, 'returnType') = 'integer'
attr(`PCAResult_row_lim_get`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_row_lim_get`) = c("SWIGFunction", class('PCAResult_row_lim_get'))

# Start of PCAResult_col_lim_set

`PCAResult_col_lim_set` = function(self, s_col_lim)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_col_lim = as.integer(s_col_lim);
  
  if(length(s_col_lim) > 1) {
    warning("using only the first element of s_col_lim");
  };
  
  ;.Call('R_swig_PCAResult_col_lim_set', self, s_col_lim, PACKAGE='rgeoda');
  
}

attr(`PCAResult_col_lim_set`, 'returnType') = 'void'
attr(`PCAResult_col_lim_set`, "inputTypes") = c('_p_PCAResult', 'integer')
class(`PCAResult_col_lim_set`) = c("SWIGFunction", class('PCAResult_col_lim_set'))

# Start of PCAResult_col_lim_get

`PCAResult_col_lim_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PCAResult_col_lim_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`PCAResult_col_lim_get`, 'returnType') = 'integer'
attr(`PCAResult_col_lim_get`, "inputTypes") = c('_p_PCAResult')
class(`PCAResult_col_lim_get`) = c("SWIGFunction", class('PCAResult_col_lim_get'))

# Start of accessor method for PCAResult
setMethod('$', '_p_PCAResult', function(x, name)

{
  accessorFuns = list('setMethod' = PCAResult_setMethod, 'setStandardDev' = PCAResult_setStandardDev, 'setPropOfVar' = PCAResult_setPropOfVar, 'setCumProp' = PCAResult_setCumProp, 'setThresh95' = PCAResult_setThresh95, 'setEigenValues' = PCAResult_setEigenValues, 'setScores' = PCAResult_setScores, 'setLoadings' = PCAResult_setLoadings, 'setSqCorrelations' = PCAResult_setSqCorrelations, 'setPriComponents' = PCAResult_setPriComponents, 'getMethod' = PCAResult_getMethod, 'getStandardDev' = PCAResult_getStandardDev, 'getPropOfVar' = PCAResult_getPropOfVar, 'getCumProp' = PCAResult_getCumProp, 'getThresh95' = PCAResult_getThresh95, 'getEigenValues' = PCAResult_getEigenValues, 'getLoadings' = PCAResult_getLoadings, 'getSqCorrelations' = PCAResult_getSqCorrelations, 'getPriComponents' = PCAResult_getPriComponents, 'getKComponents' = PCAResult_getKComponents, 'setKaiser' = PCAResult_setKaiser, 'getKaiser' = PCAResult_getKaiser, 'row_lim' = PCAResult_row_lim_get, 'col_lim' = PCAResult_col_lim_get);
  vaccessors = c('row_lim', 'col_lim');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for PCAResult
# Start of accessor method for PCAResult
setMethod('$<-', '_p_PCAResult', function(x, name, value)

{
  accessorFuns = list('row_lim' = PCAResult_row_lim_set, 'col_lim' = PCAResult_col_lim_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PCAResult', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('row_lim' = PCAResult_row_lim_set, 'col_lim' = PCAResult_col_lim_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for PCAResult
setMethod('delete', '_p_PCAResult', function(obj) {delete_PCAResult(obj)})
# Start of gda_pca

`gda_pca__SWIG_0` = function(data, method)
{
  data = lapply(data, as.numeric);
  method = as(method, "character"); 
  ;ans = .Call('R_swig_gda_pca__SWIG_0', data, method, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_PCAResult", ref=ans);
  
  ans
  
}

attr(`gda_pca__SWIG_0`, 'returnType') = '_p_PCAResult'
attr(`gda_pca__SWIG_0`, "inputTypes") = c('list', 'character')
class(`gda_pca__SWIG_0`) = c("SWIGFunction", class('gda_pca__SWIG_0'))

# Start of gda_pca

`gda_pca__SWIG_1` = function(data)
{
  data = lapply(data, as.numeric);
  ;ans = .Call('R_swig_gda_pca__SWIG_1', data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_PCAResult", ref=ans);
  
  ans
  
}

attr(`gda_pca__SWIG_1`, 'returnType') = '_p_PCAResult'
attr(`gda_pca__SWIG_1`, "inputTypes") = c('list')
class(`gda_pca__SWIG_1`) = c("SWIGFunction", class('gda_pca__SWIG_1'))

`gda_pca` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- gda_pca__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- gda_pca__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_pca with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of gda_mds

`gda_mds__SWIG_0` = function(data, k, dist_method, use_power_iteration, power_max_iter, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  dist_method = as(dist_method, "character"); 
  use_power_iteration = as.logical(use_power_iteration);
  power_max_iter = as.integer(power_max_iter);
  
  if(length(power_max_iter) > 1) {
    warning("using only the first element of power_max_iter");
  };
  
  ;.Call('R_swig_gda_mds__SWIG_0', data, k, dist_method, use_power_iteration, power_max_iter, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_mds__SWIG_0`, 'returnType') = 'list'
attr(`gda_mds__SWIG_0`, "inputTypes") = c('list', 'integer', 'character', 'logical', 'integer')
class(`gda_mds__SWIG_0`) = c("SWIGFunction", class('gda_mds__SWIG_0'))

# Start of gda_mds

`gda_mds__SWIG_1` = function(data, k, dist_method, use_power_iteration, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  dist_method = as(dist_method, "character"); 
  use_power_iteration = as.logical(use_power_iteration);
  ;.Call('R_swig_gda_mds__SWIG_1', data, k, dist_method, use_power_iteration, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_mds__SWIG_1`, 'returnType') = 'list'
attr(`gda_mds__SWIG_1`, "inputTypes") = c('list', 'integer', 'character', 'logical')
class(`gda_mds__SWIG_1`) = c("SWIGFunction", class('gda_mds__SWIG_1'))

# Start of gda_mds

`gda_mds__SWIG_2` = function(data, k, dist_method, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  dist_method = as(dist_method, "character"); 
  ;.Call('R_swig_gda_mds__SWIG_2', data, k, dist_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_mds__SWIG_2`, 'returnType') = 'list'
attr(`gda_mds__SWIG_2`, "inputTypes") = c('list', 'integer', 'character')
class(`gda_mds__SWIG_2`) = c("SWIGFunction", class('gda_mds__SWIG_2'))

# Start of gda_mds

`gda_mds__SWIG_3` = function(data, k, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  ;.Call('R_swig_gda_mds__SWIG_3', data, k, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_mds__SWIG_3`, 'returnType') = 'list'
attr(`gda_mds__SWIG_3`, "inputTypes") = c('list', 'integer')
class(`gda_mds__SWIG_3`) = c("SWIGFunction", class('gda_mds__SWIG_3'))

# Start of gda_mds

`gda_mds__SWIG_4` = function(data, .copy = FALSE)
{
  data = lapply(data, as.numeric);
  ;.Call('R_swig_gda_mds__SWIG_4', data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`gda_mds__SWIG_4`, 'returnType') = 'list'
attr(`gda_mds__SWIG_4`, "inputTypes") = c('list')
class(`gda_mds__SWIG_4`) = c("SWIGFunction", class('gda_mds__SWIG_4'))

`gda_mds` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 1) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- gda_mds__SWIG_4; 
    }
  } else if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- gda_mds__SWIG_3; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- gda_mds__SWIG_2; 
    }
  } else if (argc == 4) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- gda_mds__SWIG_1; 
    }
  } else if (argc == 5) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- gda_mds__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for gda_mds with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecGeoDaColumn___nonzero__

`VecGeoDaColumn___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___nonzero__`, 'returnType') = 'logical'
attr(`VecGeoDaColumn___nonzero__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn___nonzero__`) = c("SWIGFunction", class('VecGeoDaColumn___nonzero__'))

# Start of VecGeoDaColumn___len__

`VecGeoDaColumn___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___len__`, 'returnType') = 'integer'
attr(`VecGeoDaColumn___len__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn___len__`) = c("SWIGFunction", class('VecGeoDaColumn___len__'))

# Start of VecGeoDaColumn_pop

`VecGeoDaColumn_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_pop`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn_pop`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_pop`) = c("SWIGFunction", class('VecGeoDaColumn_pop'))

# Start of VecGeoDaColumn___getslice__

`VecGeoDaColumn___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecGeoDaColumn___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn___getslice__`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn___getslice__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', 'integer')
class(`VecGeoDaColumn___getslice__`) = c("SWIGFunction", class('VecGeoDaColumn___getslice__'))

# Start of VecGeoDaColumn___setslice__

`VecGeoDaColumn___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___setslice__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___setslice__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', 'integer', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn___setslice__`) = c("SWIGFunction", class('VecGeoDaColumn___setslice__'))

# Start of VecGeoDaColumn___delslice__

`VecGeoDaColumn___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecGeoDaColumn___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___delslice__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___delslice__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', 'integer')
class(`VecGeoDaColumn___delslice__`) = c("SWIGFunction", class('VecGeoDaColumn___delslice__'))

# Start of VecGeoDaColumn___delitem__

`VecGeoDaColumn___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecGeoDaColumn___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___delitem__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___delitem__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn___delitem__`) = c("SWIGFunction", class('VecGeoDaColumn___delitem__'))

# Start of VecGeoDaColumn___getitem__

`VecGeoDaColumn___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_VecGeoDaColumn___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn___getitem__`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn___getitem__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn___getitem__`) = c("SWIGFunction", class('VecGeoDaColumn___getitem__'))

# Start of VecGeoDaColumn___setitem__

`VecGeoDaColumn___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___setitem__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___setitem__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn___setitem__`) = c("SWIGFunction", class('VecGeoDaColumn___setitem__'))

# Start of VecGeoDaColumn_append

`VecGeoDaColumn_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_append`, 'returnType') = 'void'
attr(`VecGeoDaColumn_append`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', '_p_GeoDaColumn')
class(`VecGeoDaColumn_append`) = c("SWIGFunction", class('VecGeoDaColumn_append'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_0`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
class(`VecGeoDaColumn__SWIG_0`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_0'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_1`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn__SWIG_1`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn__SWIG_1`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_1'))

# Start of VecGeoDaColumn_empty

`VecGeoDaColumn_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_empty`, 'returnType') = 'logical'
attr(`VecGeoDaColumn_empty`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_empty`) = c("SWIGFunction", class('VecGeoDaColumn_empty'))

# Start of VecGeoDaColumn_size

`VecGeoDaColumn_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_size`, 'returnType') = 'integer'
attr(`VecGeoDaColumn_size`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_size`) = c("SWIGFunction", class('VecGeoDaColumn_size'))

# Start of VecGeoDaColumn_swap

`VecGeoDaColumn_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_swap`, 'returnType') = 'void'
attr(`VecGeoDaColumn_swap`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_swap`) = c("SWIGFunction", class('VecGeoDaColumn_swap'))

# Start of VecGeoDaColumn_clear

`VecGeoDaColumn_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_clear`, 'returnType') = 'void'
attr(`VecGeoDaColumn_clear`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_clear`) = c("SWIGFunction", class('VecGeoDaColumn_clear'))

# Start of VecGeoDaColumn_get_allocator

`VecGeoDaColumn_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_GeoDaColumn_p_t", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_get_allocator`, 'returnType') = '_p_std__allocatorT_GeoDaColumn_p_t'
attr(`VecGeoDaColumn_get_allocator`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_get_allocator`) = c("SWIGFunction", class('VecGeoDaColumn_get_allocator'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_2`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn__SWIG_2`, "inputTypes") = c('integer')
class(`VecGeoDaColumn__SWIG_2`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_2'))

# Start of VecGeoDaColumn_pop_back

`VecGeoDaColumn_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_pop_back`, 'returnType') = 'void'
attr(`VecGeoDaColumn_pop_back`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_pop_back`) = c("SWIGFunction", class('VecGeoDaColumn_pop_back'))

# Start of VecGeoDaColumn_resize

`VecGeoDaColumn_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecGeoDaColumn_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecGeoDaColumn_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn_resize__SWIG_0`) = c("SWIGFunction", class('VecGeoDaColumn_resize__SWIG_0'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_3`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn__SWIG_3`, "inputTypes") = c('integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn__SWIG_3`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_3'))

`VecGeoDaColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecGeoDaColumn__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecGeoDaColumn__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t') && length(argv[[1]]) == 1) {
      f <- VecGeoDaColumn__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_GeoDaColumn') && length(argv[[2]]) == 1) {
      f <- VecGeoDaColumn__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecGeoDaColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecGeoDaColumn_push_back

`VecGeoDaColumn_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_push_back`, 'returnType') = 'void'
attr(`VecGeoDaColumn_push_back`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', '_p_GeoDaColumn')
class(`VecGeoDaColumn_push_back`) = c("SWIGFunction", class('VecGeoDaColumn_push_back'))

# Start of VecGeoDaColumn_front

`VecGeoDaColumn_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_front', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_front`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn_front`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_front`) = c("SWIGFunction", class('VecGeoDaColumn_front'))

# Start of VecGeoDaColumn_back

`VecGeoDaColumn_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_back', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_back`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn_back`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_back`) = c("SWIGFunction", class('VecGeoDaColumn_back'))

# Start of VecGeoDaColumn_assign

`VecGeoDaColumn_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_assign`, 'returnType') = 'void'
attr(`VecGeoDaColumn_assign`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn_assign`) = c("SWIGFunction", class('VecGeoDaColumn_assign'))

# Start of VecGeoDaColumn_resize

`VecGeoDaColumn_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecGeoDaColumn_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn_resize__SWIG_1`) = c("SWIGFunction", class('VecGeoDaColumn_resize__SWIG_1'))

`VecGeoDaColumn_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecGeoDaColumn_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_GeoDaColumn') && length(argv[[3]]) == 1) {
      f <- VecGeoDaColumn_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecGeoDaColumn_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecGeoDaColumn_reserve

`VecGeoDaColumn_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecGeoDaColumn_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_reserve`, 'returnType') = 'void'
attr(`VecGeoDaColumn_reserve`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn_reserve`) = c("SWIGFunction", class('VecGeoDaColumn_reserve'))

# Start of VecGeoDaColumn_capacity

`VecGeoDaColumn_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_capacity`, 'returnType') = 'integer'
attr(`VecGeoDaColumn_capacity`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_capacity`) = c("SWIGFunction", class('VecGeoDaColumn_capacity'))

# Start of delete_VecGeoDaColumn

`delete_VecGeoDaColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecGeoDaColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecGeoDaColumn`, 'returnType') = 'void'
attr(`delete_VecGeoDaColumn`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`delete_VecGeoDaColumn`) = c("SWIGFunction", class('delete_VecGeoDaColumn'))

# Start of accessor method for std::vector<(p.GeoDaColumn)>
setMethod('$', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecGeoDaColumn___nonzero__, '__len__' = VecGeoDaColumn___len__, 'pop' = VecGeoDaColumn_pop, '__getslice__' = VecGeoDaColumn___getslice__, '__setslice__' = VecGeoDaColumn___setslice__, '__delslice__' = VecGeoDaColumn___delslice__, '__delitem__' = VecGeoDaColumn___delitem__, '__getitem__' = VecGeoDaColumn___getitem__, '__setitem__' = VecGeoDaColumn___setitem__, 'append' = VecGeoDaColumn_append, 'empty' = VecGeoDaColumn_empty, 'size' = VecGeoDaColumn_size, 'swap' = VecGeoDaColumn_swap, 'clear' = VecGeoDaColumn_clear, 'get_allocator' = VecGeoDaColumn_get_allocator, 'pop_back' = VecGeoDaColumn_pop_back, 'resize' = VecGeoDaColumn_resize, 'push_back' = VecGeoDaColumn_push_back, 'front' = VecGeoDaColumn_front, 'back' = VecGeoDaColumn_back, 'assign' = VecGeoDaColumn_assign, 'reserve' = VecGeoDaColumn_reserve, 'capacity' = VecGeoDaColumn_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(p.GeoDaColumn)>
setMethod('delete', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', function(obj) {delete_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t(obj)})

defineEnumeration("_GeoDaWeight__WeightType",
 .values=c("gal_type" = .Call('R_swig_GeoDaWeight_gal_type_get',FALSE, PACKAGE='rgeoda'),
"gwt_type" = .Call('R_swig_GeoDaWeight_gwt_type_get',FALSE, PACKAGE='rgeoda')))

defineEnumeration("_GeoDaColumn__FieldType",
 .values=c("integer_type" = .Call('R_swig_GeoDaColumn_integer_type_get',FALSE, PACKAGE='rgeoda'),
"string_type" = .Call('R_swig_GeoDaColumn_string_type_get',FALSE, PACKAGE='rgeoda'),
"real_type" = .Call('R_swig_GeoDaColumn_real_type_get',FALSE, PACKAGE='rgeoda')))

defineEnumeration("_GeoDa__MapType",
 .values=c("point_type" = .Call('R_swig_GeoDa_point_type_get',FALSE, PACKAGE='rgeoda'),
"polygon_type" = .Call('R_swig_GeoDa_polygon_type_get',FALSE, PACKAGE='rgeoda'),
"line_type" = .Call('R_swig_GeoDa_line_type_get',FALSE, PACKAGE='rgeoda'),
"unknown_type" = .Call('R_swig_GeoDa_unknown_type_get',FALSE, PACKAGE='rgeoda')))


